---
title:  "Tomcat - 1 소개"
search: true
toc: true
toc_sticky: true
comments: true
categories:
  - Tomcat
  - Java
last_modified_at: 2014-10-04T02:21:00-05:00
---

본 내용은 톰캣을 좀더 잘 알고 잘 써보기 위한 제안이랄까요?

톰캣의 특성상 쉽게 접할 수 있는 메뉴얼적인 지식보다는, 톰캣을 더 잘 사용하고 운영 할 수 있을만한 아이디어를 공유하고자 시작한 지식공유 활동입니다. 담고 있는 내용은 **'[톰캣 알고 쓰기](http://www.youtube.com/playlist?list=PLQUXE_kb6KOj0mvxoAGrz3FT9EDL3fa1z)'** 유튜브 강의 내용에 대한 정리입니다. 유튜브에 강의를 올리면 출퇴근 시간을 이용해 짬짬히 들을 수 있을 것 같은 생각이 들어 시작하였지만 ~~얼마나 출퇴근 시간에 이용하셨을지는 미지수이고~~ 동영상으로 모든 것을 다 표현할 수 없다는 점을 감안하여 다시 글로 정리합니다.

톰캣을 잘 사용하고 이해하는 것은 개발자, 운영자, 기술자, 엔지니어등 톰캣을 접하는 모두에게 요구되는 사항이지만 일반적으로는 필요한 기능과 기술만을 습득하게 됩니다. 이번 강의를 통해 약간의 시간 투자로 모두에게 도움이 되었으면 합니다.

특히 WEB/WAS 엔지니어로 자주 겪는 상황인 ++개발 톰캣으로하고 정작 운영은 다른 WAS를 사용하는++ 아이러니함에도 도움이 되었으면 합니다.



## 1. 톰캣 소개

- 왜 톰캣을 쓰는가?
- 톰캣 이력
- 톰캣 구성
- TomEE?

<iframe width="560" height="315" src="https://www.youtube.com/embed/P3H-7G_Y3rI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

- - -

### 1.1 왜 톰캣을 쓰는가?
톰캣을 사용하는 첫번째 이유는 기능적인 이유일 것입니다. 즉, 톰캣이 수행하는 역할인 JSP/Servlet 엔진으로서의 역할이겠지요. 톰캣은 세계적으로 가장 많은 Java 기반의 웹어플리케이션 플랫폼으로 사용되고 있습니다. 많은 개발자들이 자신의 첫번째 Java 웹 어플리케이션의 JSP/Servlet 엔진으로 선택하고 있고 실제 운영환경에서도 사용하기에 상당한 양의 노하우를 쉽게 접할 수 있다는 장점이 있습니다.

두번째로는 아마도 무료로 사용할 수 있다는 점이 톰캣을 사용하게 되는 이유일 것입니다. 수많은 벤더사에서 JSP/Servlet 엔진과 추가로 Java Enterprise 기능을 사용할 수 있는 세련되고 검증된 자신만의 제품을 개발하고 상용화 하고 있습니다. 하지만 이러한 제품은 비용이 추가된다는 (큰)고민이 생깁니다. 물론 유지보수 계약을 통해 기술지원과 더불어 든든한 책임전가의 대상(?)인 벤더사가 존재한다는 장점이 있지만 모든 사용자가 이런 비용을 지불할 수 있는것은 아니겠지요.

![rebellabs:App Server Most of Used](../../../Library/Mobile Documents/com~apple~CloudDocs/Markup/images/app-server-used-most-often-graph.jpg)


Java 웹 어플리케이션을 실행하는 Application Server의 종류는 거의 30가지에 달하나 조사된 통계에 따르면 반정도를 Tomcat이 점유하고 있다고 합니다. 여러가지 이유가 더 있겠지만 앞서 언급한 많은 레퍼런스와 무료라는 큰 특징으로 인해 수많은 사용자가 톰캣을 사용하고 있습니다.

- - -

### 1.2 톰캣 이력
톰캣의 정식 명칭은 Apache Tomcat Server 입니다. 이를 줄여 톰캣 **Tomcat** 이라고 흔히 불려지고 있지요. 톰캣의 간단한 이력은 다음과 같습니다.

| 기준               | 2014년 9월 25일                        |
| ------------------ | -------------------------------------- |
| Deveoloper         | Apache Software Foundation             |
| Stable release     | 8.0.12 (2014-09-03)                    |
| Development Status | Active                                 |
| Written in         | Java                                   |
| Operating System   | Cross-Platform                         |
| Type               | Servlet Container / HTTP Web Server    |
| License            | Apache License 2.0                     |
| Website            | [tomcat.apache.org](tomcat.apache.org) |

현재까지 출시된 버전은 8.0.12 버전이고 앞으로도 지속적으로 업데이트가 있을 예정입니다. 무료로 제공되는 이유로 인해 톰캣을 기반으로 한 소프트웨어들이 있는데, 이경우 개발된 시점을 기준으로 톰캣 버전이 고정되어 있는 경우가 있습니다. 4.0 버전은 최근 보이지 않지만 JDK 1.4.2 를 사용하던 시기가 가장 많은 Java 웹 어플리케이션이 개발되던 시기이기에 톰캣 5.5 버전은 아직도 상당히 많은 사용처가 있을것이라 보여집니다.

- - -

### 1.3 톰캣 구성 요소
톰캣을 구성하는 핵심적인 요소는 다음의 세가지 컴포넌트입니다.

![Tomcat_Component](https://github.com/Great-Stone/share/blob/master/assets/img/2014-10-04-Tomcat/tomcat_component_do.jpg)

Catalina는 아마도 톰캣을 사용하면 가장 많이 보게되는 단어 중 하나일 것입니다.

- Catalina 컴포넌트는 서블릿을 처리하는 역할을 수행합니다.
- Coyote는 HTTP 요청을 처리하는 역할을 수행하는 컴포넌트로서 톰캣에 TCP를 통한 프로토콜을 생성하고 관리합니다.
- Jasper는 jsp 페이지를 처리하는 컴포넌트로서 jsp 로 만들어진 페이지를 처리하는 서블릿 입니다.

처리되는 컴포넌트의 역할을 이해한다면 톰캣에서 어플리케이션 수행시 발생되는 코드 스텍을 이해하는데 도움이 될 수 있습니다.

- - -

### 1.4 TomEE?
톰캣에 대하여 흔히들 '톰캣은 완전한 WAS(Web Application Server)가 아니다'라고 합니다. 앞서 설명하였지만 톰캣은 JSP/Servlet 엔진의 역할을 수행합니다. 하지만 Java Enterprise 기능인 EJB, JTA, JMS, WebService 등은 포함되어 있지 않죠. 이러한 이유로 WAS의 일부 기능만을 수행 할 수 있을 뿐 WAS는 아니다 라고 합니다. 이러한 Enterprise 요소를 지원하기위한 요구사항으로 OpenEJB나 Apache ActiveMQ, Apache CXF등의 컴포넌트 요소가 톰캣과는 별도의 프로젝트로 진행되어 해당 컴포넌트들을 결합함으로 톰캣에서 이를 지원할 수 있었습니다. 이제는 어느정도 시간이 지나 Enterprise 컴포넌트와의 연계성이 뚜렷해졌고 통합이 가능해짐에 따라 톰캣을 Java Enterprise 스펙에 맞게 재 조정하는 프로젝트가 시작됩니다. 이를 TomEE(Tomcat Enterprise Edition)이라 합니다.

TomEE의 대표 홈페이지는 [tomee.apache.org](http://tomee.apache.org)이며 상세한 설명과 문서가 준비되어있기 때문에 사용하는데 큰 어려움이 없습니다. TomEE에서 지원하는 Java Enterprise 컴포넌트들은 다음과 같습니다.

**TomEE(Default)**
The Web Profile version of TomEE Contains

- CDI - Apache OpenWebBeans
- EJB - Apache OpenEJB
- JPA - Apache OpenJPA
- JSF - Apache MyFaces
- JSP - Apache Tomcat
- JSTL - Apache Tomcat
- JTA - Apache Geronimo Transaction
- Servlet - Apache Tomcat
- Javamail - Apache Geronimo JavaMail
- Bean Validation - Apache BVal

**TomEE+** 
The TomEE Plusdistribution adds the followings

- JAX-RS - Apache CXF
- JAX-WS - Apache CXF
- JMS - Apache ActiveMQ
- Connector - Apache Geronimo Connector

현재 국내의 개발 환경이나 운영 환경에서는 이전에 잠시 EJB가 사용되었을 뿐 최근 전자정부 프레임워크에서도 보이듯 Enterprise 환경을 요구하는 상황은 거의 없는 것으로 보입니다. 아무래도 WAS 의존성을 낮추기 위해서는 벤더에서 주도하여 각각의 컴포넌트를 제공하는 Enterprise 구성 요소에 대한 의존도를 낮출 수 있는 방향이기는 하겠지요. 하지만 일부의 경우는 Enterprise 구성 요소를 잘 사용하기만 하면 어렵지 않게 안정적이고 보안적으로 보장되는 서비스의 구현이 가능할 것입니다.

부가적인 설명을 드리자면 JDK 버전과 Java Enterprise 버전은 서로 범위가 다릅니다. Java Standard기능은 JDK 버전과 같지만 Java Enterprise 기능은 JDK 버전과는 별개로 WAS에서 지원하는 컴포넌트의 요소에 따라 그 버전을 달리 합니다. 앞서 대표적인 국내 프레임워크로 Spring 프레임워크를 사용하는 전자정부 프레임워크를 예로 들었지만 국내와는 달리 국외 통계를 본다면 Java Enterprise의 사용은 그리 생소하지 않습니다.

![JavaUsed](https://www.googledrive.com/host/0B2BH_HdKKfdKZDUwZlVHSnJOM3c)

따라서 Java Enterprise 환경을 고려한다면 톰캣을 기반으로 한 TomEE를 활용하는 방법도 톰캣에 익숙한 개발자들에게는 도움이 될 수 있겠습니다.

* * *

##2. 설치환경

- OS
- JDK

@[설치환경](http://youtu.be/XvinTBrQ0ig)

- - -

###2.1 OS
톰캣을 설치하는 OS 플랫폼 환경은 모든 환경을 지원한다. 그나마 예전에는 일부 Unix/Linux/OSX 환경에서 Apache HTTP Server 설치하듯 컴파일을 통해 구성하였으나, 최근에는 압축파일을 해제하고 바로 사용할 수 있는 경우가 대부분입니다.
톰캣을 운영하기 위해 OS를 선택해야하는 입장이라면 다음과 같은 설치 타입을 고려할 수 있습니다.

- Windows : Zip 파일을 풀어 사용하거나 윈도우 서비스에 등록하는 설치
- Unix/Linux/OSX : tar 파일을 풀어 사용하거나 컴파일하여 설치

###2.2 JDK
톰켓의 버전이 올라감에 따라 지원하는 Java Standard Spec Version 또한 변경됩니다. 이 경우 일부 상위 버전은 JDK의 특정 버전에서 지원되지 않을 수 있지요. 따라서 개발되는 어플리케이션의 JDK요구치나 표준화된 톰캣 버전에 따라 지원되는 JDK 버전이 상이할 수 있습니다. 다음의 표를 참고하시기 바랍니다.

| Servlet Spec | JSP Spec | EL Spec | WebSocket Spec | Apache Tomcat Version | Actual Release Revision | Support Java Versions         |
| ------------ | -------- | ------- | -------------- | --------------------- | ----------------------- | ----------------------------- |
| 3.1          | 2.3      | 3.0     | 1.0            | 8.0.x                 | 8.0.12                  | 7+                            |
| 3.0          | 2.2      | 2.2     | 1.0            | 7.0.x                 | 7.0.55                  | 6+(WebSocket 1.0 Requires 7+) |
| 2.5          | 2.1      | 2.1     | N/A            | 6.0.x                 | 6.0.41                  | 5+                            |
| 2.4          | 2.0      | N/A     | N/A            | 5.5.x                 | 5.5.36                  | 1.4 or 5+                     |
| 2.3          | 1.2      | N/A     | N/A            | 4.1.x                 | 4.1.40                  | 1.3+                          |
| 2.2          | 1.1      | N/A     | N/A            | 3.3.x                 | 3.3.2                   | 1.1+                          |

톰캣 5.5.x 버전의 경우 5.5.12 버전 이후로는 JDK 5 이상을 지원함에 유의합니다.

JDK의 경우 OS 플랫폼에 따라 제공하는 벤더가 다른 경우가 있습니다.

- Windows/Solaris/Linux/OSX : Oracle에서 제공하는 JDK를 사용합니다.
- AIX : IBM에서 제공하는 JDK를 사용합니다.
- HP-UX : HP에서 제공하는 JDK를 사용합니다.

AIX의 JDK경우 Windows환경에도 설치가 가능하기는 하지만 일반적으로는 Oracle에서 제공하는 기존 SunJDK를 설치하여 사용합니다.

OSX는 JDK6 까지는 Apple사에서 제공하지만 JDK7부터는 Oracle에서 설치파일을 받아 설치합니다.

* * *

##3. 설치

- 설치파일 받기
- 윈도우에 설치하기
- 유닉스/리눅스에 설치하기
- 설치 후 작업
- 디렉토리 구조

@[설치](http://youtu.be/621YGq7ulS4)

- - -

설치되는 톰캣의 최상위 경로는 $CATALINA_HOME 으로 표현합니다.

###3.1 설치파일 받기
설치파일은 톰캣 홈페이지에서 좌측의 ==Downloads==에서 설치하고자 하는 버전을 선택하면 우측에 Binary와 Source Code 두가지 형태로 받을 수 있습니다. Binary는 OS플랫폼에 맞게 미리 준비된 설치파일로서 Core에 해당하는 파일을 받습니다. 종류는 여섯가지로 나뉘어 있습니다.

- zip
- tar.gz
- 32-bit Windows zip
- 64-bit Windows zip
- 64-bit Itanium Windows zip
- 32-bit/64-bit Windows Service Installer

zip과 tar.gz는 Unix/Linux환경에서 사용할 압축된 형태의 파일이고 나머지 네가지는 CPU 아키텍쳐에 맞게 컴파일된 zip 형태의 압축 파일과 서비스에 등록할수 있는 형태의 인스톨러로 구성되어 있습니다. 설치하고자 하는 OS와 CPU 아키텍처에 맞는 설치파일을 받아 준비합니다.

###3.2 윈도우에 설치하기
Windows에는 압축파일을 풀어 설치하는 방법과 서비스 등록을 위한 인스톨러 두가지 방식이 있었습니다. 압축파일 형태의 경우 압축을 풀기만하면 바로 실행이 가능합니다. 서비스 인스톨러의 경우 서비스에 등록하기 위한 설치 경로와 같은 정보를 입력하여 진행합니다.

압축파일로 설치한 경우 "%CATALINA_HOME%\bin"에 위치한 'startup.bat'으로 시작하고 'shutdown.bat'으로 종료합니다.

서비스로 설치한 경우 윈도우 서비스 관리 유틸리티에서 서비스의 '시작/종료'를 사용하거나 'net start (서비스이름)' 또는 'net stop (서비스이름)'을 사용하여 서비스의 시작과 종료가 가능합니다.

###3.3 유닉스/리눅스/맥 에 설치하기
Unix/Linux의 binary 설치파일은 압축을 풀어 설치합니다.

"$CATALINA_HOME/bin"에 위치한 'startup.sh'으로 시작하고 'shutdown.sh'으로 종료합니다.

###3.4 설치 후 작업
설치 방법은 매우 간단하나 설치 후 꼭 해야할 작업이 있습니다. Java Home을 설정하고 성능을 위한 Native library를 설치하는 작업 입니다.

Java Home의 경우 앞서 JDK를 OS에 설치하였다면 톰캣에서 이를 사용할 수 있도록 경로를 잡아주는 과정입니다. OS자체의 PATH나 환경변수로 지정하는 방법도 있고 톰캣의 스크립트에 변수로 넣어주는 방법이 있습니다. OS자체의 PATH로 설정하는 경우 해당 OS에 설치된 모든 Java 실행환경이 영향을 받게 됩니다. 따라서 일관된 서비스, 일관된 톰캣 운영 환경인 경우 같은 Java Home이 설정되는 장점이 있습니다. 이와달리 스크립트에 Java Home을 설정하면 해당 톰캣에서만 관련 설정의 영향을 받습니다. OS내에 서로 다른 JDK로 동작하는 서비스나 어플리케이션이 있다면 스크립트를 이용하는 방법을 사용할 수 있습니다.

####3.4.1 Java Home 설정하기
OS 환경에 Java Home을 설정하는 방법은 다음과 같습니다. (Java Home은 JDK의 bin 디렉토리를 포함한 상위 디렉토리 입니다.)

**Windows**
내컴퓨터 우클릭 > 고급 > 환경변수 > JAVA_HOME 추가
![JavaHomeOnWindows](https://www.googledrive.com/host/0B2BH_HdKKfdKdEFISEJsd2VVeG8)

**Unix/Linux/OSX**
계정 홈의 .profile (bash 쉘의 경우 .bash_profile)에 다음을 설정

`export JAVA_HOME=/usr/java/jdk1.7.0_55`

스크립트에 Java_Home을 설정하는 경우 catalina.sh(bat)에 JAVA_HOME 으로 지정하는 경우가 있습니다. 추가로 setenv.sh(bat)을 생성하여 해당 스크립트에 설정하는 방법이 있습니다. 

```Windows
Windows 환경>
JAVA_HOME=C:\Progra~1\java\jdk1.7.0_55```
​```Unix/Linux/OSX
Unix/Linux/OSX 환경>
JAVA_HOME="/usr/java/jdk1.7.0_55"```

Windows환경에서 Java를 Program Files에 설치하는 경우 중간에 공백이 있기 때문에 Progra~1로 표현함에 주의합니다. (스크립트에 Java Home을 추가하는 방법에 대해 소홀히 설명하는 이유는 뒤에 setenv를 설명하기 위함입니다.)

####3.4.2 Native Library 적용하기
톰캣의 Native Library를 적용하지 않고도 충분히 톰캣을 실행하고 사용할 수 있습니다. 다만 톰캣의 콘솔 로그에 다음의 메시지가 걸리적(?)거리게 발생합니다.
​```log
The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path
```

굳이 필요하지 않다면 적용하지 않아도 되지만 Native Library가 주는 이점은 다음과 같습니다.

- Non-blocking I/O for Keep-Alive requests (between requests)
- Uses OpenSSL for TLS/SSL capabilities (if supported by linked APR library)
- FIPS 140-2 support for TLS/SSL (if supported by linked OpenSSL library)

결국 NIO^Non-Blocking^ ^I/O^를 지원하는 것과 SSL관련 설정을 지원합니다. OpenSSL을 사용하지 않아도 NIO를 사용하는 성능상의 이점을 제공합니다.

Native Library를 사용하기 위해서는 APR과 Tomcat Native 소스 파일이 필요합니다. APT은 Apache 2.0 이상 버전이 설치되어있다면 해당 설치 경로의 "$APACHE_HOME/bin/apr-1-config"과 같이 존재하나 없는 경우 별도의 APR을 설치합니다. 

Apache APR 홈페이지 : http://apr.apache.org/

APR 홈페이지에서 받은 apr-x.x.x.tar.gz 파일은 다음의 순서를 따라 설치를 진행하며, 예제와 같이 "/usr/local"에 설치하는 경우 root 계정이 필요합니다.

```script
$ gzip -d apr-1.5.1.tar.gz
$ tar -xvf apr-1.5.1.tar
$ configure --prefix=/usr/local/apr-1.5.1
$ make
$ make install
```

일반적인 경우 Tomcat이 설치되면 설치된 경로의 "$CATALINA_HOME/bin" 위치에 tomcat-native.tar.gz 형태로 설치 파일이 존재하나 없는 경우, 혹은 높은 버전을 설치하고 싶은 경우 별도로 다운로드 받아 진행합니다. Native의 다운로드는 톰켓 홈페이지의 좌측 ==Downloads==의 하위에 [Tomcat Native](http://tomcat.apache.org/download-native.cgi)로 존재합니다. 
![TomcatNativeDownload](https://www.googledrive.com/host/0B2BH_HdKKfdKREJfLXlKQmt6QU0)

관련 링크를 클릭하면 우측에 OS플랫폼에 맞게 소스를 받을 수 있는 링크가 제공됩니다. 

Native Library는 다음과 같이 설치를 진행합니다.

```Script
$ gzip -d tomcat-native.tar.gz
$ tar -xvf tomcat-native.tar
$ configure --prefix=$CATALINA_HOME --with-apr=/usr/local/apr-1.5.1/bin/apr-1-config  --with-java-home=$JAVA_HOME
$ make
$ install
```

소스의 컴파일과 설치가 완료되면 "$CATALINA_HOME/lib"에서 libtcnative 관련 파일의 확인을 할 수 있습니다.

Native Library가 해당 플랫폼 환경에 맞게 생성되었다면 Shared Library로 설정하여 적용하며 적용방법은 앞서 Java Home을 설정하는 방법을 이용합니다. Shared Library 환경변수명은 OS마다 상이함에 주의하며 setenv.sh(bat)에 적용하는 방법은 다음과 같습니다.

```NitiveLibrary
setenv.sh(bat) >
LD_LIBRARY_PATH "$CATALINA_HOME/lib"
```

| OS      | Shared Library Path     |
| ------- | ----------------------- |
| Windows | PATH                    |
| Solaris | LD_LIBRARY_PATH         |
| HP-UX   | SHLIB_PATH              |
| AIX     | LIBPATH,LD_LIBRARY_PATH |
| Linux   | LD_LIBRARY_PATH         |
| OS/2    | LIBPATH                 |
| OSX     | LD_LIBRARY_PATH         |

적용된 Native Library는 톰캣의 콘솔 로그 "$CATALINA_HOME/logs/catalina.out(log)"에서 다음의 메시지를 확인 할 수 있습니다.

```log
Info: Loaded APR based Apache Tomcat Native library 1.1.31.
```

* * *

##4. 환경설정

- 리스너
- 자바옵션
- 클래스로더
- setenv?
- web.xml
- 로그

@[환경설정](http://youtu.be/DFBJ7r1u0Jo)

- - -

###4.1 리스너
리스너는 Tcp로 활성화되는 HTTP 프로토콜을 상징하여 설명합니다. 톰캣은 기본적으로 HTTP, AJP, Shutdown 을 위한 port가 활성화 됩니다. 리스너는 우리 몸의 귀와 같은 역할을 합니다. 들려오는 요청을 받는 역할을 하지요. 톰캣 또한 요청을 받아들이기 위해 리스너를 활성화하여 요청을 받아 들입니다.

이러한 리스너는 톰캣의 "Coyote" 컴포넌트가 담당하는데 톰캣의 "Startup.sh(bat)"을 수행하면 다음과 같은 메시지를 확인할 수 있습니다.

```log
7월 15, 2014 5:46:18 오후 org.apache.coyote.AbstractProtocol start 정보: Starting ProtocolHandler ["http-bio-8080"]
7월 15, 2014 5:46:18 오후 org.apache.coyote.AbstractProtocol start 정보: Starting ProtocolHandler ["ajp-bio-8009"]
7월 15, 2014 5:46:18 오후 org.apache.catalina.startup.Catalina start 정보: Server startup in 1002 ms
```

http에 8080포트가 할당되고 ajp에 8009포트가 할당됩니다. 이런 포트로 톰캣에 HTTP 혹은 AJP로 요청을 전달할 수 있습니다. 만약 톰캣이 기동된 서버의 IP가 "192.168.0.10"이고 사용되는 HTTP 포트가 8080 이라면

`http://192.168.0.10:8080`

이렇게 브라우저에서 호출이 가능합니다. 해당 IP가 DNS나 별도의 호스팅 서비스를 통해 "www.tomcat-gm.com"에 연결되어 있다면

`http://www.tomcat-gm.com:8080`

이렇게 호출이 가능합니다.

일반적으로는 HTTP의 기본 포트로 80이 사용되고 HTTPS(SSL)의 기본 포트로 443이 사용됩니다. 이경우 별도의 포트 지정없이 url 요청이 가능합니다. 

`http://www.tomcat-gm.com(:80)`

`https://www.tomcat-gm.com(:443)`

이러한 리스너 설정은 톰캣의 설정에서 'Connector'로 정의됩니다. "$CATALINA_HOME/conf" 디렉토리의 'server.xml'을 열어보시면 다음과 같은 Connector 설정을 확인 할 수 있습니다.

```xml
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               minSpareThreads="10"
               maxSpareThreads="5"
               maxThreads="15"
               redirectPort="8443" />
```

프로토콜의 형태가 "HTTP/1.1"이고 포트는 "8080"으로 활성화 됩니다. 해당 플랫폼에 IP가 여러개 존재한다면 "address" 항목을 추가하여 별도의 IP를 지정 할 수도 있습니다. 이같은 설정은 AJP나 SSL 또한 마찬가지 입니다.

###4.2 Java Options
Java의 장점이 무엇인가 물으면 그 대표적인 한가지는 OS 플랫폼에 종속적이지 않은 어플리케이션 개발이 가능하다 일 것입니다. 이런 개발 환경이 가능한 이유는 JVM^Java^ ^Virtual^ ^Machine^이 제공하는 환경 때문입니다. JVM이 동작하면 각 OS에 Java가 공통적으로 수행되기 위한 Runtime 환경을 만들고 이후 생성된 JVM 환경에서 어플리케이션이 수행되기 때문에 OS 플랫폼 마다 개발을 달리하지 않아도 됩니다. 하지만 각각의 플랫폼에서의 JVM은 그 동작의 목적은 같아도 어플리케이션에 따라 성능에 차이가 발생할 수 있습니다. 어떤 어플리케이션은 한번에 큰 메모리를 요구하는가 하면 때로는 계산을 주로 한다던가, IO 작업이 많다던가 하는 식이죠. 따라서 JVM에서는 사용자가 조절할 수 있는 수많은 옵션을 제공합니다. 물론 아무것도 설정하지 않은 상태가 가장 일반적일 수는 있지만 성능이나 장애극복을 위해 Java Option이 추가되기도 합니다. 적용되는 Java Option은 다음과 같은 것들이 있습니다.

- -Xms(ms): Heap 메모리의 최소값을 정의합니다.
- -Xmx(mx): Heap 메모리의 최대값을 정의합니다.
- -verbosegc: JVM에서 수행하는 GC를 로그로 남깁니다.
- -XX:+AggressiveOpts: 소수점 컴파일을 최적화 합니다.
- -Djava.net.preferIPv4Stack=true: IPv4와 IPv6모두 사용할 수 있는 환경에서 IPv4를 우선하여 서비스 합니다.

이 외에도 수많은 Java Option이 존재하기에 각 환경에 맞는 Java Option의 적용이 필요하겠습니다. 하지만 어플리케이션이 실제 수행되기 전에는 어떤 요구사항이 발생하는지는 알 수 없기 때문에 반드시 실 서비스를 하기 전 충분한 테스트가 필요합니다.

톰캣에서 Java Options의 추가를 위해서는 스크립트에 추가하는 방법과 Windows 서비스에 등록된 경우 관련 설정창에 추가하는 방법이 있습니다.

![TomcatServiceOptions](https://www.googledrive.com/host/0B2BH_HdKKfdKVkt1eFp0SFpRMEk)
(서비스로 등록된 톰캣에 Java Options 적용 예)

###4.3 ClassLoader
Java 환경에서는 class를 호출하여 서비스를 수행합니다. 각 class는 단독으로, 혹은 여러개가 함께 각각의 Class에 정의된 역할을 수행합니다. 이런 Class를 사용하기 위해서는 ClassLoader가 Class를 읽어 Class를 나열하는 과정이 수행됩니다. 나열되는 Class들은 경로의 형태를 띄며 이를 ClassPath라고도 부릅니다.

`...:class:class:class:class:...`

ClassLoader가 Class를 읽지 못한다면 JVM에서는 해당 Class에 들어있는 Method를 요청할 때 찾지 못하는 상황이 발생하며, 이경우 ClassNotFound 메시지를 발생시킵니다.
또한 이렇게 정의되는 ClassPath에는 우선순위가 있습니다. 동일한 Class명의 동일한 Method이지만 다른 역할을 수행하는 Class가 로딩된다면 어떤것이 우선권을 갖을까요? ClassPath순서상 앞서있는 Class가 우선권을 갖습니다. 아래와 같은 ClassPath가 생성되었다면 classA가 우선권을 갖습니다.

`...:classA:classB:classC:classE:...`

그렇다면 어플리케이션 개발자가 의도한 Class를 호출하기 위해서는 ClassLoader가 원하는 class를 앞서 설정하도록 해야합니다. 물론 겹치는 Class가 없다는 가정하에는 어떤 위치에 있던지 상관없이 읽히기만 하면 되겠지요.

일반적으로 웹 어플리케이션 개발시 Class는 "WEB-INF/classes" jar형태의 라이브러리는 "WEB-INF/lib"에 위치시킵니다. 이렇게 위치된 Class들은 톰캣 혹은 WAS에 배치^deploy^되면 전체 JVM의 가장 뒤에 위치하게 됩니다. 간혹 웹 어플리케이션 형태가 아닌 Class나 라이브러리를 적용하기위해서는 "CLASSPATH"라는 변수를 사용하여 ClassLoader가 읽을 수 있도록 합니다. 해당 변수는 WAS마다 상이할 수 있습니다.

실행되는 JVM에서의 ClassLoader 순서를 보면 다음과 같습니다.

`BootClassPath:ExtensionClassPath:ClassPath`

BootClassPath와 ExtensionClassPath는 Java의 기본 라이브러리를 로딩합니다. rt.jar와 같은 필수 라이브러리가 그 예입니다. 만약 기존 JVM을 hooking하는 식의 클래스를 사용하는 경우에는 이보다 앞서 클래스를 위치시킬 필요가 있습니다. HelloWorld라는 클래서를 BootClassPath앞에 위치하게 하려면 '-Xbootclasspath/p:HelloWorld', 뒤에 적용하려면 '-Xbotclasspath/a:HelloWorld' 형태를 사용하여 적용합니다. p와 a에 주의합니다. 그리고 일반적인 Class가 위치하는 ClassPath에 위치하게 하기 위해서는 톰켓의 경우 스크립트에 'CLASSPATH'변수를 치환합니다. 그 예는 다음과 같습니다.

```script
export CLASSPATH=HelloWorld
export CLASSPATH=${CLASSPATH}:HelloWorld
export CLASSPATH=HelloWorld:${CLASSPATH}

```

기 적용된 CLASSPATH가 있는가에 따라 적용하고자하는 Class 혹은 라이브러리 앞, 뒤에 기존 CLASSPATH를 넣어줄 수도 있습니다.

Windows의 경우 구분자가 세미콜론(;)이고 그 외에는 콜론(:)임에 주의합니다.

###4.4 setenv?
Windows 환경의 서비스 실행방법을 제외하고는 대부분 스크립트에 앞서 설명한 Java Option이나 ClassPath를 설정합니다. 일반적으로, 그리고 여러 운영환경에서 이러한 실행 환경 변수를 'catalina.sh(bat)'에 설정하여 사용하는 경우를 보았습니다. 하지만 한번이라도 해당 스크립트를 열어 읽어보셨다면 다음과 같은 메시지를 확인 할 수 있을 것입니다.

```sh
# -----------------------------------------------------------------------------
# Control Script for the CATALINA Server
#
# Environment Variable Prerequisites
#
#   Do not set the variables in this script. Instead put them into a script
#   setenv.sh in CATALINA_BASE/bin to keep your customizations separate.
```

즉, 'catalina.sh'는 건드리지 말고 'setenv.sh(bat)'에 추가적은 설정을 하라는 안내 문구 입니다. 'catalina.sh'를 수정하는 경우 해당 톰캣을 이전하거나, 동일한 톰캣을 구성하거나, 또는 복구해야 하는 상황에서 추가로 설정되거나 수정된 내용의 확인이 힘들 수 있고 또한 설정과 수정으로 인한 비정상 동작을 할 수 있기 때문입니다. 그렇다면 'setenv.sh(bat)'은 어떻게 작용할까요? 'catalina.sh(bat)'에서 'setenv'를 찾아보면 다음과 같이 'setenv'스크립트에 적용된내용을 읽어오는 것을 확인 할 수 있습니다.

```sh
(catalina.bat)
rem Get standard environment variables
if not exist "%CATALINA_BASE%\bin\setenv.bat" goto checkSetenvHome
call "%CATALINA_BASE%\bin\setenv.bat"
goto setenvDone
:checkSetenvHome
if exist "%CATALINA_HOME%\bin\setenv.bat" call "%CATALINA_HOME%\bin\setenv.bat"
:setenvDone
```

```sh
(catalina.sh)
if [ -r "$CATALINA_BASE/bin/setenv.sh" ]; then
  . "$CATALINA_BASE/bin/setenv.sh"
elif [ -r "$CATALINA_HOME/bin/setenv.sh" ]; then
  . "$CATALINA_HOME/bin/setenv.sh"
fi
```

이같이 톰캣에서는 추가/수정해야하는 환경변수나 설정값을 하나의 스크립트에서 관리할 수 있는 환경을 제공합니다. 다만 'setenv'스크립트는 별도로 만들어야 합니다. 앞서 'catalina.sh(bat)'의 설명된 변수들을 보면 Java Options은 'JAVA_OPTS'로하지 말고 'CATALINA_OPTS'로 하라는 점도 주의해서 보시기 바랍니다. 'JAVA_OPTS'의 경우 톰캣을 정지시키는 'shutdown.sh(bat)'에서도 호출되기 때문에 차후 소개되는 JMX 모니터링을 위한 옵션과 같이 별도의 포트를 활성화하는 옵션과 같은 성격의 설정 적용시 문제가 될 수 있습니다. 'setenv'스크립트에 다음과 같이 추가하면 해당 옵션을 별도로 export하지 않아도 톰캣 기동시 적용됩니다.

```dos
(setenv.bat)
set CATALINA_OPTS=-Xms1024m -Xmx2048m -XX:MaxPermSize=512m -verbosegc
set CLASSPATH=%CLASSPATH%;/app/libs/myapi.jar
```

```sh
(setenv.sh)
CATALINA_OPTS="-Xms1024m -Xmx2048m -XX:MaxPermSize=512m -verbosegc"
CLASSPATH="${CLASSPATH}:/app/libs/myapi.jar"
```

###4.5 web.xml
웹 어플리케이션에서 'web.xml'은 서블릿을 정의하고 이어주는 역할을 수행합니다. 이와 마찬가지로 톰캣에 있는 "$CATALINA_HOME/conf/web.xml" 또한 톰캣에 있는 서블릿을 정의하고 이어주는 역할을 수행합니다. 다만 JSP/Servlet 엔진으로서의 최소한의 정의를 합니다.

- Servlet 처리 맵핑
- Jsp 처리 맵핑
- 추가 모듈 설정
- Global Session Timeout
- mime 정의

따라서 톰캣에 배치되는 모든 어플리케이션에서 공통으로 수정되어야 할 사항은 web.xml에도 정의할 수 있습니다. 하지만 앞서 'catalina' 스크립트와 마찬가지로 추가/수정시 부작용이 있을 수 있음에 중의합니다.

###4.6 Log
톰캣의 로그는 다음과 같이 종류와 정의는 다음에서 정의합니다. 다만 Windows 서비스는 서비스 환경설정에서 정의힙니다.

| Log          | Config File                                                  |
| ------------ | ------------------------------------------------------------ |
| Catalina.out | CATALINA_OUT 환경변수로 정의, catalina.sh에 정의되어 있고 setenv 스크립트에서 재정의 |
| access.log   | server.xml                                                   |
| *.log        | logging.properties                                           |

* * *

##5. 배치

- Web Application
- by Manager
- by webapps DIR
- by context.xml
- ROOT
- Auto Deployment & Hot Deployment
- Parallel Deployment

@[배치](http://youtu.be/Hg-D7szI2t4)

@[배치a](http://youtu.be/Bp789a8MBWI)

@[배치b](http://youtu.be/kOp9ahbtE9Q)

- - -

###5.1 Web Application
톰캣에 배치되는 어플리케이션은 Java Web Application입니다. 간단히 웹 어플리케이션이라고도 합니다. 간략한 구조는 다음과 같습니다.

```directory
APPDIR / WEB-INF / web.xml
                 / lib / jar-files
                 / classes / class-files
```

APP 디렉토리 하위에는 웹어플리케이션의 정의를 넣을 WEB-INF 디렉토리가 필요합니다. 아주 간단한 어플리케이션은 'web.xml'에 다음의 태그만 넣어도 웹 어플리케이션으로 인지할 수 있습니다.

```xml
<web-app/>
```

- - -

###5.2 by Manager
어플리케이션을 배치하는 방법에는 톰캣에서 제공하는 'manager'를 사용하는 방법이 있습니다. manager는 톰캣을 설치하면 제공되는 어플리케이션 관리 툴로 다음과 같이 확인할 수 있습니다.

- http://ip:port 로 기본 톰캣 http 요청 (로컬에서 기본 설정으로 실행한 경우 http://localhost:8080)
  ![ROOTAPP](https://www.googledrive.com/host/0B2BH_HdKKfdKMVExLUFaZ01ZVEE)

- ROOT 어플리케이션의 호출 확인 후 좌측의 'Manager App' 버튼 클릭

- 톰캣 유저의 설정이 되어있지 않으므로 로그인 창에서 '취소'버튼 클릭
  ![ManagerLogin](https://www.googledrive.com/host/0B2BH_HdKKfdKcG1zZGg4YXBTbW8)

- $CATALINA_HOME/conf/tomcat-user.xml 에 설정하는 방법을 에러페이지에서 확인

 - tomcat-user.xml에 다음과 같이 설정 추가 (user/passwd를 admin/admin으로 설정)

- ```xml
  <tomcat-users>
  <role rolename="manager-gui"/>
  <user username="admin" password="admin" roles="manager-gui"/>
  </tomcat-users>```
  ```

- 톰캣 재기동 후 다시 로그인 페이지 호출하여 설정한 user/passwd 입력 후 로그인

manager의 중간에 'Deploy'에서 배치를 수행할 수 있으며 두가지 타입이 제공됩니다. 한가지는 'Deploy directory or WAR file located on server'로서 톰캣이 기동된 서버내의 어플리케이션을 지정하여 배치하는 방법과 'WAR file to deploy'는 현재 접속중인 로컬의 WAR파일을 업로드하여 배치하는 방법입니다.

![managerDeploy](https://www.googledrive.com/host/0B2BH_HdKKfdKZkg3N241WlJHcTA)

두 방법 모두 수행 후 "$CATALINA_HOME/webapps" 에 해당 어플리케이션이 위치하게 됩니다.

- - -

###5.3 by webapps DIR
톰캣에는 자동으로 어플리케이션을 인지하고 배치하는 디렉토리가 있습니다. 바로 "$CATALINA_HOME/webapps"입니다. 해당 경로는 앞서 manager 를 통한 배치시에도 어플리케이션이 위치하게되는 경로인데, 앞서 manager를 사용하는 방법은 결국 webapps 디렉토리에 어플리케이션을 위치시키는 작업이라고 볼 수 있습니다. 따라서 직접 해당 경로에 어플리케이션을 위치시켜도 동일하게 배치 작업이 발생합니다.

webapps 디렉토리가 자동으로 배치를 수행하는 설정은 'server.xml'에서 해당 경로가 배치를 수행하도록 설정되었기 때문입니다. 

```xml
<Host name="localhost"  appBase="webapps" unpackWARs="true" autoDeploy="true">
    <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
           prefix="localhost_access_log." suffix=".txt"
           pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
```

'server.xml'에서 확인 할 수 있는 톰캣의 기본 host 환경인 'localhost'에서 webapps 디렉토리를 대상으로 autoDeploy를 수행한다는 설정 내용입니다. 이러한 설정으로 인해 자동으로 어플리케이션의 배치가 가능합니다.

- - -

###5.4 by context.xml
앞서 두가지의 manager나 webapps 디렉토리를 통한 배치 방법은 모두 톰캣 내부의 webapps 디렉토리에 어플리케이션이 위치하게 된다는 특징이 있습니다. 이러한 점은 사용자가 원하는 임의의 위치에 어플리케이션은 배제 된다는 의미 일 수도 있습니다. 따라서 이경우 context.xml 형태의 xml을 통한 배치 방법을 사용 할 수 있겠습니다.

배치를 설명하기에 앞서 context.xml의 'context' 디스크립터는 본래 server.xml에 위치하는 디스크립터였습니다. 하지만 해당 디스크립터에 설정되는 내용들은 변경사항이 자주 발생하는 항목들이기에 별도의 xml에서도 정의할 수 있도록 변경되었으며, 톰캣 5.5.12 버전부터는 server.xml이 아닌 별도의 context.xml을 통하여 해당 설정들을 관리하도록 권고하고 있습니다.

'context.xml'에서 설정하는 정보는 어플리케이션 뿐만이 아니기 때문에 어플리케이션 설정을 제외한 설정을 톰캣에 적용하는 경우에도 사용됩니다. 'context.xml'은 <context> 디스크립터로 시작되며 다음의 위치에서 적용되고, 위치에 따라 적용 범위가 달라집니다.

1. $CATALINA_HOME/conf/==context.xml== : $CATALINA_HOME 내의 모든 톰켓 프로세스 내의 서비스
2. $CATALINA_HOME/conf/[ENGINENAME]/[HOSTNAME]/==context.xml.default== : Host 범위 내의 모든 서비스
3. $CATALINA_HOME/conf/[ENGINENAME]/[HOSTNAME]/==[WEBAPPNAME].xml== : 어플리케이션 범위 내의 모든 서비스
4. $WEBAPP/META-INF/==context.xml== : 어플리케이션 범위 내의 모든 서비스

이같은 위치에 따른 적용 범위는 context로 정의되는 대표적인 자원중 하나인 데이터소스^DataSource^의 경우 톰캣전체 또는 어플리케이션 별로 구분할 수 있는 기능을 사용할 수 있습니다.

어플리케이션을 배포하는 경우 위의 4가지 방법 중 3, 4번 항목을 들 수 있으며, 특히 'context.xml'을 사용한 임의의 위치의 어플리케이션 배포는 3번 항목을 사용하게 됩니다.

'sample' context-root를 갖는 어플리케이션은 다음과 같이 'context.xml'을 설정할 수 있습니다.

```xml
<?xml version="1.0" encoding="UTF-8"?>

<Context path="sample" docBase="/Users/GSLee/APP/sample" debug="0" reloadable="true" crossContext="true" privileged="true"/>

<!-- path는 해당 설정을 server.xml에 하는 경우 의미가 있고 3번 방법의 경우 xml 파일 이름이 context-root로 설정됩니다. -->
```

- - -

###5.5 ROOT

일반적으로 어플리케이션을 배치하는 경우 해당 어플리케이션의 디렉토리 이름이나 context로 설정된 xml의 파일 이름이 context-root로 사용됩니다.

`http://www.mytomcat.co.kr/[WEBAPPNAME]/index.jsp`

하지만 대부분의 경우 다음과 같이 요청되기를 바라죠.

`http://www.mytomcat.co.kr/index.jsp`

이경우 배치 방식은 동일하지만 다음의 네가지 방법을 통해 어플리케이션 배치 시 context-root를 '/'로 설정할 수 있습니다.

1. $CATALINA_HOME/webapps/==ROOT== : webapps 기본 디렉토리에 ==ROOT==인 디렉토리명으로 배치된 어플리케이션
2. $CATALINA_HOME/conf/[ENGINENAME]/[HOSTNAME]/==ROOT.xml== : ROOT를 이름으로 갖는 context 타입의 xml로 배치된 어플리케이션
3. Tomcat Manager APP에서 'context path' 항목을 비워놓은 채로 배치하는 어플리케이션
4. server.xml에 배치 어플리케이션을 설정하는 경우 'context' 디스크립터의 'path'항목을 비워놓음

방법은 여러가지가 있지만 앞서 설명드린 'context'디스크립터로 설정한 별도의 xml을 사용한 배치 방식을 권장합니다.

sample 어플리케이션을 ROOT로 배치한 로그는 다음과 같이 확인됩니다.

```log
정보: Starting Servlet Engine: Apache Tomcat/7.0.54
9월 06, 2014 8:30:52 오후 org.apache.catalina.startup.HostConfig deployDescriptor
정보: Deploying configuration descriptor /Users/GSLee/APP/tomcat/apache-tomcat-7.0.54/conf/Catalina/localhost/ROOT.xml
9월 06, 2014 8:30:52 오후 org.apache.catalina.core.StandardContext setPath
경고: A context path must either be an empty string or start with a '/'. The path [sample] does not meet these criteria and has been changed to [/sample]
9월 06, 2014 8:30:52 오후 org.apache.catalina.startup.SetContextPropertiesRule begin
경고: [SetContextPropertiesRule]{Context} Setting property 'debug' to '0' did not find a matching property.
9월 06, 2014 8:30:53 오후 org.rhq.helpers.rtfilter.filter.RtFilter init
정보: Initialized response-time filter for webapp with context root 'ROOT'.
9월 06, 2014 8:30:53 오후 org.apache.catalina.startup.HostConfig deployDescriptor
정보: Deployment of configuration descriptor /Users/GSLee/APP/tomcat/apache-tomcat-7.0.54/conf/Catalina/localhost/ROOT.xml has finished in 1,115 ms
```

- - -

###5.6 Auto Deployment & Hot Deployment

Auto Deploy와 Hot Deploy는 Auto와 Hot을 어떻게 해석하는가에 따라 다음과 같이 혼용되어 사용됩니다.

- 서버 프로세스가 기동 된 상태에서 배치
- 배치된 어플리케이션에 변경사항이 적용된 어플리케이션을 재배치
- 수행중인 어플리케이션의 일부 소스의 변경 적용과 반영

의미가 어떻게 해석되던지 이런 용어를 사용함에 있어서 바라는점은 서비스가 실행중인 도중에도 변경사항을 사용자 모르게 바꾸고자 하는 의도가 대부분일 것입니다.

####5.6.1 webapps 'autoDeploy'
webapps 디렉토리에 어플리케이션을 넣으면 자동으로 배치가 됩니다. 서버가 기동된 상태에서도 말이죠. 해당 설정은 다음의 'Host' 디스크립터에서 정의합니다.

```xml
<Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true">
      ...
</Host>
```

Host 설정에 autoDeploy가 'true'인 경우 해당 디렉토리에 위치하는 어플리케이션을 감지하여 자동으로 톰캣에 배치를 수행합니다.

####5.6.2 jsp 'checkInterval'
jsp를 사용자 뷰로 사용하는 경우 서비스의 컨텐츠, 또는 jsp에서 실행하는 코드상의 변경사항이 자주 발생하게 됩니다. 이경우 jsp를 새로 반영하기 위해 서버가 실행중임에도 자동으로 업데이트된 jsp를 컴파일하여 해당 소스를 반영하는 동작을 지원하는 설정이 있습니다. 해당 설정은 다음의 "$CATAILNA_HOME/conf/web.xml"의 jsp 서블릿에 정의되어 있습니다.

```xml
<servlet>
    <servlet-name>jsp</servlet-name>
    <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
    ...
    <init-param>
        <param-name>development</param-name>
        <param-value>true</param-value>
    </init-param>
    <init-param>
        <param-name>checkInterval</param-name>
        <param-value>1</param-value>
    </init-param>
    <load-on-startup>3</load-on-startup>
</servlet>
```

jsp 서블릿에서는 두가지 경우에 대해 jsp의 업데이트를 수행합니다.

- 조건 1. 'development'가 'true'인 경우 항상 확인
- 조건 2. 'development'가 'false'이고 'checkInterval'이 '0'보다 큰 경우 확인합니다.

관련 옵션에 대한 상세 내용이나 추가적인 jasper 컴포넌트의 옵션은 해당 설정의 위에 주석으로 설명이 되어있습니다.

####5.6.3 Class 'reloadable'
클래스를 수정하여 컴파일한 뒤 어플리케이션에 업로드하면 얼마 후 해당 어플리케이션(컨텍스트)를 리로딩하는 과정을 수행합니다. 해당 설정은 'Context' 디스크립터가 설정된 xml에 정의합니다.

```xml
<Context reloadable="true" ...>
    <Loader checkInterval="15"/>
    ...
</Context>
```

'reloadable'을 'true'로 설정하는 경우 해당 어플리케이션(컨텍스트)는 클래스에 변경이 발생하면 다시 리로딩하는 기능을 수행합니다. 간격은 기본 15초이기 때문에 더 빠른 방영을 원하시면 'Context'디스크립터 내에 'Loader'의 'checkInterval'을 정의함으로 시간을 조절할 수 있습니다. 하지만 이런 리로드 현상을 싫어하시는 분도 있습니다. ["Tomcat Context 수동 Reload"](kwon37xi.egloos.com/4710012)라는 블로그 글에서도 보이듯 자동 리로드를 비활성화 하고 'Valve'를 사용하는 별도의 방법을 사용할 수도 있습니다.

- - -

###5.7 Parallel Deployment

어플리케이션의 클래스가 수정되어 리로드가 발생하거나 라이브러리나 xml등의 재기동 후 반영되는 변경사항을 적용하기 위해서는 톰캣을 재기동해야 하는 상황이 발생합니다. 이런 경우 기존 어플리케이션은 기존에 사용중인 사용자가 계속 이용 할 수 있도록 활성화된 상태에서 새로운 버전의 어플리케이션을 배치, 새로운 사용자는 새로운 어플리케이션을~~(새술은 새부대에?)~~ 사용하도록 하는 'Parallel Deployment'기능을 사용 할 수 있습니다.

![parallelDeploy](https://www.googledrive.com/host/0B2BH_HdKKfdKNHFzV3dQSkVNTEk)

WebLogic Server에서도 이와 유사한 '[production redeployment](http://docs.oracle.com/middleware/1212/wls/DEPGD/redeploy.htm#DEPGD266)'기능이 있지만 톰캣이 좀더 쉬운 방법을 제안합니다.

그 방법은 'WEBAPP==##[VersionNumber]=='입니다. 'sample'어플리케이션으로 예를 들면 'sample##1.0'으로 배치를 수행하는 것입니다. 기존 어플리케이션 뒤에 샵 기호 두개와 버전이름만 붙이면 되기 때문에 매우 간단하지만 단점으로는 거의 동일한 구성과 용량의 독립적인 어플리케이션이 필요하기 때문에 어느정도 변경사항이 많은 경우 활용도가 높겠습니다. 버전은 float 형태로 정의하며 상대적으로 높은 값이 신규 배치가 됩니다. Context에서 지정하는 경우에는 어플리케이션 경로를 설정한 대로 샵 기로가 추가된 어플리케이션 이름을 지정하면 서비스 컨텍스트는 샵 기호와 버전이 제외된 기존 경로를 사용하게 됩니다.

```xml
<Context docBase="/app/sample##01" ... />
```

```xml
<Context docBase="/app/sample##02" ... />
```

배치된 어플리케이션은 톰캣 Manager에서도 다음과 같이 확인할 수 있습니다.

![appVersion](https://www.googledrive.com/host/0B2BH_HdKKfdKa2RmWnBmNm5OOFE)

버전이 높은 어플리케이션이 배치되면 기존 사용자는 이전 버전의 어플리케이션 서비스를 이용하고 새로 접속하는 사용자는 신규 어플리케이션의 서비스를 이용하게 됩니다. 이전 버전의 어플리케이션은 톰캣 Manager에서 Session을 확인하여 사용자가 없는것을 확인 후 제거할 수 있습니다.

* * *

##6. DB 연동

- JDBC Connection Pool
- DB 연동 예제
- DB 연동 설정값
- JNDI Lookup

@[DB연동](http://youtu.be/odsWlmZfzag)

- - -

###6.1 JDBC Connection Pool
JDBC Connection Pool은 Java에서 DB^Data^ ^Base^의 Session 자원을 미리 확보함으로 재생성하는 비용을 줄이기 위한 기술 입니다. Java에서 사용되는 기술이기 때문에 각 DB 벤더사들은 Java로 구현되는 서비스에서 자사의 DB를 사용할 수 있도록 별도의 라이브러리를 제공하며 이를 사용하여 DB와의 Connection을 생성하고 DB를 사용할 수 있게 됩니다.
JDBC는 여타 드라이버와는 다르게 미리 Connection을 확보하여 JVM상에 Object상태로 만들어두고 이를 요청하는 서비스에 빌려줍니다. 빌려준다는 표현을 사용한 이유는 반드시 반환되어야 하기 때문입니다. 앞서 미리 만든다는 표현은 만드는 개수가 제한되어 있다는 의미로 사용하였으며, 때문에 한정된 자원을 DB와의 연계 처리만을 하는 경우 잠시 사용하고 다시 반납하는 과정을 거칩니다.
다음은 jsp에서 단일 Oracle DB와의 Connection Pool을 생성하고 반납하는 샘플 코드입니다.(~~테스트 용도로 씁니다.~~)

```xml
<%@ page import="java.sql.*" %>
<%
  StringBuffer sbError = new StringBuffer();
  DatabaseMetaData dbMetaData = null;
  Connection conn = null;
%>
<font size="-1"><p>
<%
  DriverManager.registerDriver (new oracle.jdbc.OracleDriver());
  try {
    conn = DriverManager.getConnection("jdbc:oracle:thin:@172.16.1.128:1521:TOSA1", "fmsvr", "fmsvr");
    dbMetaData = conn.getMetaData();
%>
<p>
Name of JDBC Driver: <%= dbMetaData.getDriverName() %><br>
Version: <%= dbMetaData.getDriverVersion() %><br>
Major: <%= dbMetaData.getDriverMajorVersion() %><br>
Minor: <%= dbMetaData.getDriverMinorVersion() %><br>
<p>
Database Name: <%= dbMetaData.getDatabaseProductName() %><br>a
Version: <%= dbMetaData.getDatabaseProductVersion() %><br>
<%
  } catch (SQLException e) {
    sbError.append(e.toString());
  } finally {
    if (conn != null) {
      try {
        conn.close();
      } catch (SQLException e) {
        sbError.append(e.toString());
      }
    }
  }
  if (sbError.length() != 0) {
    out.println(sbError.toString());
  } else {
%>
<p>No error</font>
<%
  }
%>
```

주어진 정보로 getConnection()을 수행하고 다시 close()를 수행하여 반납하는 과정이며, close()하지 않는 경우 해당 객체는 모두 사용하였음에도 불구하고 메모리상에 남아 차후 메모리 이슈를 발생시킬 수 있습니다.

톰캣에서는 이런 일련의 Connection을 생성하는 작업을 어플리케이션 대신 생성할 수 있으며 내부적으로 생성하는 개수나 연결이 끊어졌을 때의 재시도, 사용하지 않는 Connection의 강제 반환 등의 설정이 가능합니다.

다음은 'Context' 디스트립터 내에 설정하는 'Resource'에서 정의한 DataSource 예제 입니다.

```xml
<Resource name="jdbc/test"
          auth="Container"
          type="javax.sql.DataSource"
          username="oracle"
          password="oracle"
          driverClassName="oracle.jdbc.driver.OracleDriver"
          url="jdbc:oracle:thin:@address:1521:SID"
          removeAbandoned="true"
          removeAbandonedTimeout="60"
          logAbandoned="true"
          maxActive="25"
          maxIdle="10"
          maxWait="-1"
/>
```

- - -

###6.2 DB 연동 예제

톰캣에서 DB를 연동하기 위해서는 우선 사용할 DB의 벤더사에서 제공하는 JDBC driver를 ClassLoader에서 읽도록 해야 합니다. 우선 JDBC driver를 받고 두가지 방법으로 적용이 가능합니다.

- setenv script

```sh
#JDBC Driver Classpath
CLASSPATH=/app/lib/jdbc.jar
```

- lib 디렉토리에 복사
 - $CATALINA_HOME/common/lib/jdbc.jar (5.5) or
 - $CATALINA_HOME/shared/lib/jdbc.jar (5.5)
 - $CATALINA_HOME/lib/jdbc.jar (6+)

대표적인 DB의 'Context' 디스크립터에 설정하는 방법은 다음과 같습니다.

```xml
<!-- MySQL - Connector/J -->
<Resource name="jdbc/test"
          auth="Container"
          type="javax.sql.DataSource"
          username="javauser"
          password="javadude" 
          driverClassName="com.mysql.jdbc.Driver" 
          url="jdbc:mysql://ipaddress:3306/javatest" 
          maxActive="25"
          maxIdle="10"
          maxWait="-1"
/>
```

```xml
<!-- Oracle - classes12.jar(jdk1.4.2), ojdbc#.jar(5+) -->
<Resource name="jdbc/test"
          auth="Container"
          type="javax.sql.DataSource"
          username="oracle"
          password="oracle" 
          driverClassName="oracle.jdbc.driver.OracleDriver" 
          url="jdbc:oracle:thin:@ipaddress:1521:SID" 
          maxActive="25"
          maxIdle="10"
          maxWait="-1"
 />
```

```xml
<!-- PostgreSQL - JDBC # -->
<Resource name="jdbc/test"
          auth="Container" 
          type="javax.sql.DataSource" 
          username="myuser"
          password="mypasswd" 
          driverClassName="org.postgresql.Driver" 
          url="jdbc:postgresql://ipaddress:5432/mydb" 
          maxActive="25"
          maxIdle="10"
          maxWait="-1"
/>
```

- - -

###6.3 DB 연동 설정값
'Resource'에 정의되는 항목은 기본적인 url이나 DB접근 계정정도만 있어도 가능하지만 간혹 튜닝이나 문제해결을 위해 추가적인 옵션이 요구되는 경우가 있습니다. 톰캣에서는 다음의 설정값을 제공합니다.

| ATTRIBUTE              | DESCRIPTOIN                                 | DEFAULT      |
| ---------------------- | ------------------------------------------- | ------------ |
| maxActive              | 최대 Connection 값                          | 100          |
| maxIdle                | Idle Connection 최대 허용치                 | =maxActive   |
| minIdle                | Idle Connection 최소 허용치                 | =initialSize |
| initialSize            | Connection Pool의 최초 생성 개수            | 10           |
| maxWait                | Connection을 얻기위해 대기하는 최대 시간    | 30000(ms)    |
| removeAbandoned        | 특정시간 동안 사용하지 않는 Connection 반환 | false        |
| removeAbandonedTimeout | removeAbandoned가 동작하는데 소요되는 시간  | 60(s)        |
| logAbandoned           | Connection이 remove될 때 log에 기록         | false        |
| testOnBorrow           | getConnection()이 수행될 때 유효성 테스트   | false        |
| validationQuery        | 테스트를 위한 쿼리                          | null         |

'validationQuery'로는 다음과 같이 적용 가능합니다.

- mysql, MSSql : SELECT 1
- Oracle : select 1 from dual

[http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html](http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html)

- - -

###6.4 JNDI Lookup
톰캣에서 생성한 JDBC Connection Pool을 DataSource로서 사용하기 위해서는 JNDI를 Lookup하는 방법을 사용합니다. JNDI를 사용하면 이를 지원하는 다른 프레임워크나 API에서도 톰캣의 자원을 사용할 수 있습니다. mybatis/ibatis의 경우도 JNDI 설정을 할 수 있습니다.

'Context'디스크립터로 정의한 DataSource는 어플리케이션의 'web.xml'에서 정의하고 소스에서는 'lookup'을 이용하여 사용합니다. 일련의 설정방법의 예는 다음과 같습니다. Context의 정의의 위치에 따라 전체 어플리케이션에 적용될 수도 있고 host단위, 혹은 단일 어플리케이션 내에서만 자원을 생성하게 됩니다.

```xml
<!-- context.xml -->
<Resource name="jdbc/test"
          auth="Container"
          type="javax.sql.DataSource"
          username="oracle"
          password="oracle" 
          driverClassName="oracle.jdbc.driver.OracleDriver" 
          url="jdbc:oracle:thin:@ipaddress:1521:SID" 
 />
```

```xml
<!-- web.xml -->
<web-app>
    ...
    <resource-ref>
        <res-ref-name>jdbc/test</res-ref-name>
        <res-type>javax.sql.DataSource</res-type>
        <res-auth>Container</res-auth>
    </resource-ref>
    ...
</web-app>
```

```java
//Source Code
ds = ctx.lookup("java:comp/env/jdbc/test");
```

* * *


##7. 호스트

- 호스트 구성
- 호스트 특징
- host manager

@[Host](http://youtu.be/hnLzh_WE8R8)

- - -

###7.1 호스트 구성
톰캣에 정의된 바로는 '호스트'로 정의되나 일반적인 기능으로 표현한다면 가상 호스트^Virtual^ ^Host^와 같은 기능 입니다. 특정 host 명, 즉 http url로 서비스를 분기하는 역할을 합니다. 'server.xml' 기본으로 설정되어있는 'localhost'인 호스트의 내용은 다음과 같습니다.

```xml
<Engine name="Catalina" defaultHost="localhost">
    <Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true">
    ...
    </Host>
</Engine>
```

설정된 내용을 분석해본다면 'Catalina'라는 톰캣의 엔진에서 처리하는 기본 호스트는 'localhost'이고, 'localhost'는 'webapps' 디렉토리를 기본 배치 디렉토리고 갖는다는 내용입니다. 기본 호스트로 지정된 호스트는 이외에 설정된 호스트 조건에 맞지 않은 모든 요청을 처리하게 됩니다. 이렇게 생성된 'localhost'는 "$CATALINA_HOME/conf/[ENGINENAME]/[HOSTNAME]" 과 같은 경로에 호스트만의 설정 값을 갖게 됩니다. 

![localhostDIR](https://www.googledrive.com/host/0B2BH_HdKKfdKUUgxVENZYnZGODA)

별도의 호스트 추가는 'Engine' 디스크립터 하위에 'Host' 디스크립터로 정의합니다. 'myhost'라는 호스트는 다음과 같이 추가할 수 있습니다.

```xml
<Engine name="Catalina" defaultHost="localhost">
    <Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true">
    ...
    </Host>
    <Host name="myhost" appBase="webapps_myhost" unpackWARs="true" autoDeploy="true">
    ...
    </Host>
</Engine>
```

새롭게 추가되는 호스트는 기본 배치경로를 다르게 설정합니다. 때문에 동일한 컨텍스트의 요청이라도 어떤 호스트가 처리하는가에 따라 다른 어플리케이션의 서비스를 이용하게 됩니다. 설정 후 톰캣 프로세스를 재기동하면 호스트 설정 디렉토리가 생성됨을 확인 할 수 있습니다.

![myhostDIR](https://www.googledrive.com/host/0B2BH_HdKKfdKVFI3eVdRUVk0Umc)

- - -

###7.2 호스트 특징

호스트의 기능은 주로 웹서버에서 많이 사용되는 기능입니다. 특정 url로 호출되는 요청을 각 요청 전달 목적지에 맞게 분배하는 역할을 수행하지요. 호스트는 톰캣에도 구현되어 있으며 이를 통해 하나의 톰캣 내에서 같은 컨텍스트를 갖는 요청의 처리가 가능합니다.

![hostROOT](https://www.googledrive.com/host/0B2BH_HdKKfdKQlFSU1R2M0d0WFU)

톰캣의 프로세스를 서비스 마다 생성하지 못하는 상황(e.g. 자원의 한계와 같은) 또는 서비스에서 소모하는 자원이 크지 않아 추가적인 프로세스를 기동하지 않아도 되는 상황 등 호스트의 기능을 활용 할수 있습니다.

- - -

###7.3 host manager

호스트를 관리하기 위해 톰캣에서는 'host manager'를 제공합니다. 앞서 배치에서 보았던 'Manage APP'와 같이 호스트를 쉽게 구성할 수 있도록 UI환경을 제공합니다. 이를 통해 설정파일에 직접 수정하기보다 제공되는 UI로 정확하고 쉽게 구성하고 관리할 수 있도록 합니다.

- http://ip:port 로 기본 톰캣 http 요청 (로컬에서 기본 설정으로 실행한 경우 http://localhost:8080)
  ![ROOTAPP](https://www.googledrive.com/host/0B2BH_HdKKfdKMVExLUFaZ01ZVEE)

- ROOT 어플리케이션의 호출 확인 후 좌/우측의 'Host Manager' 클릭

- 톰캣 유저의 설정이 되어있지 않으므로 로그인 창에서 '취소'버튼 클릭
  ![ManagerLogin](https://www.googledrive.com/host/0B2BH_HdKKfdKcG1zZGg4YXBTbW8)

- $CATALINA_HOME/conf/tomcat-user.xml 에 설정하는 방법을 에러페이지에서 확인

 - tomcat-user.xml에 다음과 같이 설정 추가 (user/passwd를 admin/admin으로 설정)

- ```xml
  <tomcat-users>
    <role rolename="manager-gui"/>
    <role rolename="admin-gui"/>
    <user username="admin" password="admin" roles="manager-gui,admin-gui"/>
  </tomcat-users>```
  ```

- 톰캣 재기동 후 다시 로그인 페이지 호출하여 설정한 user/passwd 입력 후 로그인
  ![hostmanager](https://www.googledrive.com/host/0B2BH_HdKKfdKVTkyV0Z0QTNXTjA)

'host manager'에서는 기본 호스트 외에 추가적인 호스트에 대한 추가를 할 수 있도록 'Add Virtual Host'를 사용할 수 있습니다. 'Host' 디스크립터에서 정의되는 내용을 각 항목에 맞게 입력 할 수 있고 이렇게 추가된 호스트는 'Host name' 테이블의 'commands'에서 개별적으로 시작과 정지가 가능합니다. 호스트가 정지되어 비활성화 된 상태에서는 해당 호스트의 요청 url에 맞게 들어오더라도 기본 호스트가 처리하게 됩니다. 'host manager'는 웹페이지를 통한 호스트의 추가/삭제/컨트롤이 가능하므로 외부, 또는 관리자가 아닌 사용자가 접근하지 못하도록 해야 합니다.

* * *

##8. 웹서버 연동

- 웹서버 연동의 이유
- mod_jk
- 클러스터

@[웹서버연동](http://youtu.be/j6qeCBWM4YI)

- - -

###8.1 웹서버 연동의 이유

톰캣 단일로 서비스하는 경우도 있지만 일반적으로 웹서버와 연동하여 사용하는 경우가 보다 더 많습니다. 그 이유를 다음과 같이 정리합니다.

####8.1.1 요청분산

톰캣에서 처리하는 서비스 요청이 증가하면 단일 프로세스로 처리가 부족한 상황이 발생합니다. 처리에 필요한 힙 메모리를 추가해야 한다면 현재 적용된 메모리 설정보다 더 많은 값을 설정하고 CPU 자원이 부족하다면 장비의 교체도 고려해 봐야겠습니다. 이런 접근은 가용한 메모리가 없거나 더 나은  장비를 추가 구입/구성 해야하는 점이 있습니다. 따라서 단일 프로세스의 한계를 유연하게 대처하기 위해 복수의 프로세스에서 동일한 서비스를 구성하는 방안을 고려할 수 있습니다. 그리고 복수의 프로세스에 요청을 전달하기 위해 LB^LoadBalancer^가 필요합니다.

LB 기능을 수행하는 대표적인 두가지는 네트워크 장비(스위치 장비: L2, L4, L7)를 사용하는 방법과 HTTP 요청을 받아 분산이 가능한 웹서버 입니다. 어떤 방법을 사용하던지 복수개의 톰캣을 사용하면 상황에 따라 프로세스를 추가하여 처리하는 용량을 증가시킬 수 있습니다. 물론 앞서 장비의 추가 상황을 제외한다면 단일 프로세스 보다는 복수의 프로세스를 사용하여 부하를 분산시킬 수 있습니다.

####8.1.2 소스분산

톰캣은 웹서버의 역할을 함께 수행할 수 있는 기능을 동반하고 있습니다. 하지만 정적인 소스를 처리함에 있어서는 기존 웹서버의 처리 능력이 더 우월하기 때문에 소스 처리의 추체를 분산시켜 처리 속도를 증가시킬 수 있습니다. 대표적인 정적인 소스는 html, css, 이미지 파일 입니다. 앞서 요청의 분산으로 부하를 분산시키는 역할과 더불어 어플리케이션 소스 또한 처리추체를 분산시키고, 더불어 웹서버와 톰캣에서 좀더 빠르게 처리 할 수 있고, 처리 가능한 요청의 처리를 분담할 수 있습니다.

####8.1.3 장애극복

일반적으로 Failover로 표현하는 장애처리 및 장애극복은 복수의 톰캣 프로세스를 사용함에 따른 장점입니다. 특정 톰캣 프로세스에 장애가 발생하더라도 다른 톰캣 프로세스에서 요청을 처리하게 됨으로 단일 프로세스로 운영할때보다 서비스 지속성에 장점을 갖습니다.

- - -

###8.2 mod_jk

웹서버는 프록시 기능만을 사용하여도 톰캣과의 연동이 가능하나 톰캣으로의 연동을 좀더 긴밀하게 하기 위해 별도의 모듈을 제공합니다. 이는 'Tomcat Connector'로 제공되는데 [http://tomcat.apache.org](http://tomcat.apache.org)의 Document와 Download에서 확인할 수 있습니다. 연동가능한 대표적인 웹서버로는 다음의 웹서버와 모듈이 요구됩니다.

- Apache HTTP Server : mod_jk.so, mod_jk.dll
- IIS : isapi_redirect.dll
- iPlanet : nsapi_redirector.so, nsapi_redirector.dll

아파치^Apache^ ^HTTP^ ^Server^는 가장 많이 사용되고 모든 플랫폼을 지원하는 대표적인 웹서버로서 이번 장에서 설명하고자하는 웹서버와의 연동에서 사용하고자 합니다. 기타 웹서버의 경우 톰캣의 [토큐먼트](http://tomcat.apache.org/connectors-doc/) 내용을 참고하시기 바랍니다.

아파치가 설치되었다는 가정하에 톰캣을 연동하는 방법은 다음과 같습니다. 

####8.2.1 mod_jk 다운로드
유닉스/리눅스/맥의 경우 mod_jk의 소스를 다운받아 아파치의 'apxs'와 함께 컴파일하는 과정이 필요합니다. 윈도우에서도 컴파일하여 사용할 수 있으나 비쥬얼 스튜디오가 있어야 컴파일을 할 수 있기 때문에 별도의 바이너리 파일로 제공됩니다.

![mod_jk_download](https://www.googledrive.com/host/0B2BH_HdKKfdKcnlZbnc5Y25VNG8)
다운로드페이지에서 플랫폼에 맞는 모듈을 다운받습니다.

####8.2.2 모듈 컴파일
유닉스/리눅스/맥의 경우 컴파일을 수행하기위해 아파치의 'apxs'가 필요합니다. 다운받은 소스 압축파일을 풀고 다음과 같이 컴파일 합니다.

```sh
$ tar xvfz tomcat-connectors-1.2.40-src.tar.gz
$ cd ~/Downloads/tomcat-connectors-1.2.40-src/native
$ ./configure —with-apxs=$APACHE_HOME_DIR/bin/apxs
$ make
$ make install
```

컴파일이 완료된 모듈은 자동으로 "$APACHE_HOME/modules/mod_jk.so"로 생성됩니다. 윈도우에서는 다운 받은 바이너리 모듈의 압축을 풀어 동일한 디렉토리에 복사하면 됩니다.

####8.2.3 모듈 설정
생성된 모듈을 아파치에서 사용할 수 있도록 설정하는 작업을 합니다. "$APACHE_HOME/conf/httpd.conf"에 설정하거나 별도의 'conf'파일을 생성하여 읽게 하여도 됩니다. 'httpd.conf'에 설정하는 내용은 다음과 같습니다.

```xml
LoadModule jk_module modules/mod_jk.so

<IfModule jk_module>
    JkWorkersFile conf/workers.properties
    JkLogFile logs/mod_jk.log
    JkLogLevel info
    JkMountFile conf/uri.properties
</IfModule>
```

'JkWorkersFile'은 요청을 처리하는 워커, 즉 톰캣을 정의하는 파일을 지정합니다.

'JkMountFile'은 워커와 워커가 처리할 요청을 맵핑하는 파일을 지정합니다. 'JkMount'만으로도 설정이 가능하나 하나의 파일에서 별도로 관리하기 위해서는 해당 파일을 지정하는 것을 권장합니다. 'httpd.conf'에 'JkMount'를 사용하는 경우 다음과 같이 정의할 수 있습니다.

```xml
#jsp 파일을 worker1 워커가 처리하는 경우
JkMount /*.jsp  worker1

#server 경로의 요청을 worker2 워커가 처리하는 경우
JkMount /servlet/* worker2
```

####8.2.4 워커 정의
워커는 그 단어의 의미에서도 추측할 수 있듯이 mod_jk에서 지정하는 요청을 처리하는 대상, 즉 톰켓 프로세스를 의미합니다. 워커는 다음과 같은 설정 방식을 따릅니다.

```xml
worker.[WORKER_NAME].[TYPE]=[VALUE]
```

설정의 예는 다음과 같습니다.

- worker.list=[WORKER_NAME] : 요청을 처리하는 워커를 나열합니다.
- worker.worker1.type=ajp13 : worker1 워커의 형태를 정의합니다.
- worker.worker2.host=192.168.0.11 : worker2 워커의 address를 정의합니다.
- worker.loadbalancer.type=lb : loadbalancer 워커의 형태를 정의합니다. 
- worker.loadbalancer.balance_workers=[WORKER_NAME] : lb 형태인 loadbalancer 워커에서 요청을 분산시킬 워커를 나열합니다.

'worker.properties'의 설정 예제는 다음과 같습니다.
![workersproperties](https://www.googledrive.com/host/0B2BH_HdKKfdKTThBN3NWTUk0V28)

해당 설정은 LB로 구성되는 워커를 정의합니다. LB로 구성될 'worker1'과 'worker2'를 정의합니다.

- 'worker1'은 '192.168.0.10'의 ip와 '8009'포트로 'ajp13'형태의 요청을 받아들이며 'lbfactor'는 1입니다.
- 'worker2'은 '192.168.0.11'의 ip와 '8009'포트로 'ajp13'형태의 요청을 받아들이며 'lbfactor'는 1입니다.
- 'loadbalancer'는 LB를 수행하기 위한 워커로 'lb' 워커 형태입니다.
- 'lb'형태의 워커는 LB 대상 워커를 'balace_workers'를 정의하여 나열합니다. 예제에서는 'worker1'과 'worker2'가 대상으로 지정되었습니다.
- 각 톰캣과의 연동 워커인 'worker1'과 'worker2'는 'lbfactor'가 같기 때문에 같은 비율로 요청이 전달됩니다.
- 요청을 처리하는 워커는 'worker.list'에 지정합니다. 예제에서는 'loadbalancer' 워커를 지정하였습니다.

####8.2.5 처리할 요청의 정의
워커의 정의로 요청을 처리할 워커가 준비되었다면 어떤 요청을 전달할지 정의해햐 합니다. 앞서 'JkMount'를 사용한 방식은 간단히 설명하였고 여기서는 'uri.properties' 파일에서 별도로 요청의 처리 맵핑을 관리하도록 하였습니다. 'JkMountFile'로 지정되는 이 설정 파일은 다음과 같은 설정 방식을 따릅니다.

```xml
[URL or FILE_EXTENSION]=[WORKER or WORKER_LIST]
```

이렇게 설정되는 설정 파일의 내용의 예는 다음과 같습니다.

```xml
/*.do=worker1
/*.jsp=worker2
/servlet/*=loadbalancer
```

'JkMount'와 표현방식에 약간의 차이('='의 사용여부)가 있음에 주의하여 설정합니다.

###8.2.6 테스트
설정이 완료되면 아파치 프로세스를 재기동 합니다. 이후 맵핑한 요청설정에 따라 아파치에 요청을 합니다. jsp파일을 톰캣이 처리하도록 설정하였다면 톰캣에서 요청해보고 url을 아파치로 변경하여 동일하게 요청되는지 확인합니다.

- - -

###8.3 클러스터
웹서버와 연동하는 주요 기능중 한가지는 장애처리입니다. 일반적으로는 이런 장애처리 동작시 기존 처리중이던 HTTP Session 정보는 장애가 발생한 톰캣이 가지고 있었기 때문에 없어지게 됩니다. 이같은 현상은 기존에 로그인하여 작업을 하던 중 해당 톰캣 프로세스에 문제가 발생하여 다른 톰캣 프로세스로 요청이 넘어가면 로그인 하던 세션이 끊겨 다시금 작업을 수행하는 현상이 발생하는 것을 예로 들수 있습니다.

톰캣에서는 장애처리시의 HTTP Session을 복구하여 지속적인 세션의 유지를 가능하게 하고자 '클러스터' 기능을 제공합니다. 클러스터는 Multicast로 톰캣 프로세스간에 클러스터를 형성하고 멤버로 구성된 톰캣간에 세션을 공유하는 방식입니다.

기능의 활성화는 단순히 'server.xml'의 'Cluster' 디스크립터의 주석을 해제하는 것만으로도 가능합니다.

![tomcatCluster](https://www.googledrive.com/host/0B2BH_HdKKfdKUTFXcGtZVjFVM2M)

하지만 동일 장비에서 기동되는 톰캣간이나 서비스가 다른 톰캣이 여럿 기동중인 경우에는 설정값들이 중복되어 톰캣 기동이나 서비스 처리시 문제가 발생할 수 있습니다. 따라서 기본적인 설정 값 외에 별도의 설정들을 적용해야 하는 경우 'server.xml'에서 클러스터를 사용하기 위한 디스크립터 위에 설명한 도큐먼트의 내용을 참고해야 합니다.

만약 도큐먼트의 설정들이 너무 많거나 어떻게 적용해야 하는지 이해하기 힘든경우 톰캣 5.5버전의 'server.xml'을 참고하시기 바랍니다. 해당 버전에서는 6.0 이후 단순히 한줄로 적용된 'Cluster' 디스크립터와는 다르게 기본적인 설정과 값이 같이 적용되어 있습니다. 아래 예제는 도큐먼트의 기본 설정에서 가져온 내용입니다.

[http://tomcat.apache.org/tomcat-7.0-doc/cluster-howto.html: 기본 설정](http://tomcat.apache.org/tomcat-7.0-doc/cluster-howto.html)

```xml
<Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
         channelSendOptions="8">

  <Manager className="org.apache.catalina.ha.session.DeltaManager"
           expireSessionsOnShutdown="false"
           notifyListenersOnReplication="true"/>

  <Channel className="org.apache.catalina.tribes.group.GroupChannel">
    <Membership className="org.apache.catalina.tribes.membership.McastService"
                address="228.0.0.4"
                port="45564"
                frequency="500"
                dropTime="3000"/>
    <Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
              address="auto"
              port="4000"
              autoBind="100"
              selectorTimeout="5000"
              maxThreads="6"/>

    <Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter">
      <Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/>
    </Sender>
    <Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/>
    <Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"/>
  </Channel>

  <Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
         filter=""/>
  <Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/>

    <Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
              tempDir="/tmp/war-temp/"
              deployDir="/tmp/war-deploy/"
              watchDir="/tmp/war-listen/"
              watchEnabled="false"/>

    <ClusterListener className="org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener"/>
    <ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/>
</Cluster>
```

앞서 여러개의 톰캣 클러스터를 사용하는 경우 'Membership'과 'Reciver' 디스크립터의 내용에 주의합니다. 'Membership'은 동일한 설정을 갖는 톰캣 끼리 같은 클러스터 멤버 그룹으로 인지하는 내용으로 멀티캐스트 통신을 수행합니다. 'Membershop'의 'address'와 'port'가 동일한 톰캣 프로세스 끼지 클러스터 기능을 수행합니다.  'Reciver'는 클러스터간의 메시지를 주고받는 역할을 수행하며 TCP 통신을 수행합니다. 따라서 동일한 장비의 톰캣은 'Reciver'에서 설정되는 'port'에 차이가 있어야 합니다.

설정된 톰캣 클러스터의 기능은 어플리케이션이 세션 복제를 허용하는가의 여부에 따라 동작하게 됩니다. 따라서 어플리케이션의 'web.xml'에 복제가능을 활성화하는 디스크립터를 추가합니다.

```xml
<web-app>
  ...
  <distributeable/>
  ...
</web-app>
```

복제 설정이 추가된 어플리케이션이 배치된 톰캣은 기동시 클러스터를 활성화하고 멤버간에 통신을 수행하여 다음과 같은 메시지가 'catalina.out'에서 확인됩니다.

![destributeable](https://www.googledrive.com/host/0B2BH_HdKKfdKc0p4RWJJSUZVTGc)

구성된 클러스터와 어플리케이션은 LB로 구성되어 요청하며 각 톰캣 프로세스는 세션을 공유하기 때문에 하나의 톰캣 프로세스가 종료되더라도 다른 톰캣 프로세스에서 세션을 받아 수행하는 것을 확인할 수 잇습니다.

* * *

##9. 쓰레드

- Thread?
- 설정
- Thread Dump

@[쓰레드](http://youtu.be/sKiEidnV0nI)

- - -

###9.1 Thread?
Thread는 JVM내에 요청된 작업을 동시에 처리하기 위한 작은 cpu라고 볼 수 있습니다. 톰캣에 서비스 처리를 요청하는 경우 해당 요청은 Queue에 쌓여 FIFO로 Thread에 전달되고 Thread에 여유가 있는 경우 Queue에 들어온 요청은 바로 Thread로 전달되어 'Queue Length'는 0을 유지하지만 Thread가 모두 사용중이여서 더이상의 요청 처리를 하지 못하는 경우 새로 발생한 요청은 Queue에 쌓이면서 지연이 발생합니다.

Thread가 많을수록 동시에 많은 요청을 처리하기 때문에 작은 Thread 수는 서비스를 지연시키지만 이에 반해 Thread도 자원을 소모하므로 필요이상의 큰 값은 불필요한 JVM의 자원을 소모하게 되고 하나의 프로세스 내의 Thread 수는 톰캣 기준으로 700개 이하로 설정할 것을 권장합니다.

사실상 요청은 지연이 최소화 되어야 하며 지연이 길어질수록 Thread를 점유하여 동시간대에 사용가능한 Thread 수를 줄이므로 적정한 Thread 개수의 설정 상태에서 요청을 더 많이 받고자 한다면 지연에 대한 문제점을 찾는 것을 우선해야 합니다.

- - -

###9.2 설정
쓰레드는 'Connector' 기준으로 생성됩니다. 따라서 HTTP나 AJP, SSL이 설정된 'Connector'마다 다른 쓰레드 수를 설정할 수 있습니다. 또는 하나의 쓰레드 풀을 생성하고 'Connector'에서 해당 쓰레드 풀의 쓰레드를 같이 사용하도록 설정할 수도 있습니다.

####9.2.1 Connector의 쓰레드 설정
기본적인 'Connector'는 다음과 같이 설정되어있습니다.

```xml
<Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000" redirectPort="8443" />
           
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
```

HTTP나 AJP 프로토콜이 정의된 'Connector'는 설정되어 있지는 않지만 기본값으로 최대 쓰레드 200개의 설정을 가지고 있습니다. 쓰레드 관련 설정값은 다음과 같습니다.

| Attribute       | Description                                                  |
| --------------- | ------------------------------------------------------------ |
| maxSpareThreads | Idle 상태로 유지할 max thread pool size                      |
| maxThreads      | 동시 요청에 의해 Connector가 생성 할 수 있는 최대 request 수 |
| minSpareThreads | tomcat을 실행할때 최소로 유지할 Idle Thread 수               |
| maxIdleTime     | Thread를 유지하는 시간(ms)                                   |

이런 설정 값들로 다시금 정의하면 기본 'Connector'를 다음과 같이 설정할 수 있습니다.

```xml
<Connector port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000" redirectPort="8443"
           maxSpareThreads="5"
           maxThreads="15"
           minSpareThreads="10" />
           
<Connector port="8009" protocol="AJP/1.3" redirectPort="8443"
           maxSpareThreads="5"
           maxThreads="15"
           minSpareThreads="10" />
```

####9.2.2 Executor
'Executor' 디스크립터는 'Connector'의 쓰레드 설정에 별도의 실행자로 설정하여 동일한 'Executor'를 사용하는 'Connector'는 같은 쓰레드 풀에서 쓰레드를 사용하도록 하는 기능입니다.

별도의 'Connector'를 사용하여 서비스하지만 모두 같은 쓰레드 자원을 사용하기 위함이며 'connector'에 'executor'라는 설정을 사용하여 공통의 쓰레드 풀을 이용할 수 있습니다. 'tomcatThreadPool'이라는 이름을 갖는 'Executor'와 각 'Connector'에 설정하는 예는 다음과 같습니다.

```xml
<Executor name="tomcatThreadPool"
          namePrefix="catalina-exec-"
          maxThreads=“150"
          minSpareThreads="4"/>

<Connector executor="tomcatThreadPool"
           port="8080" protocol="HTTP/1.1"
           connectionTimeout="20000" redirectPort="8443"/>
           
<Connector executor="tomcatThreadPool"
           port="8009" protocol="AJP/1.3" redirectPort="8443"/>
```

'Executor'에는 'name'을 정의하여 다른 'Connector'에서 해당 'Executor'를 정의할 수 있는 연결고리를 만듭니다. 그리고 쓰레드의 이름을 정의하는 'namePrifix'설정으로 다른 쓰레드와 구분할 수 있도록 합니다. 기존 'Connector'에 설정하던 쓰레드 관련 설정을 'Excutor'에 함으로서 'Connector'에 공통 쓰레드 풀을 제공합니다.

- - -

###9.3 Thread Dump
쓰레드 덤프는 실행중인 Thread의 종류와 시작점, 실행한 클래스와 메소드 순서, 현재 상태등을 기록하는 JVM의 고유 기능입니다. 쓰레드 덤프로 서비스의 흐름과 서비스 지연시 수행중인 작업, 병목등을 확인할 수 있습니다. 쓰레드 덤프로 기록된 한 쓰레드의 내용을 예로 들어보겠습니다.

![ThreadDump](https://www.googledrive.com/host/0B2BH_HdKKfdKRFd1bXhUTWQtMFk)

쓰레드 덤프의 시작에는 쓰레드 이름과 쓰레드의 정보가 기록되며 이후 쓰레드 상태에 대해 설명합니다.
트레이스의 읽는 순서는 위가 최근 실행한 클래스와 메소드이기 때문에 아래서부터 위로 읽습니다.

쓰레드 덤프를 발생시키는 법은 다음과 같습니다.

1. 프로세스 ID를 확인

 - 유닉스/리눅스/맥

 ```sh
 ps -ef | grep java
 ```

 - JDK 5+

 ```dos
 $JAVA_HOME/bin/jps
 ```

2. 쓰레드 덤프 발생

 - 유닉스/리눅스/맥

 ```sh
 kill -3 <pid>
 ```

 - JDK 5+

 ```dos
 $JAVA_HOME/bin/jstack <pid>
 ```

3. 쓰레드 덤프 확인

 - 'catalina.out' 파일 확인
 - AIX 플랫폼의 경우 별도의 javacore 파일 확인

* * *

##10. 모니터링

- 모니터링은 왜 하나?
- 톰캣 기본 모니터링 툴
- psi-Probe
- jkstatus
- visualVM
- JMC
- APM

@[모니터링](http://youtu.be/1IAghXNby-Y)

- - -

###10.1 모니터링은 왜 하나?
무엇인가에 대한 모니터링은 그 대상의 상태를 확인하기 위함입니다. 문제가 있는지, 어떤 동작을 하고 있는지, 알아야 할 내용이 있다면 그 사항을 알수 있도록 하는, 즉 대상의 상태를 감시하는 것입니다.

톰캣을 사용하여 서비스를 제공하는 입장에서는 톰캣의 상태를 감시할 수 있어야 합니다. 톰캣의 작업 상태나 자원의 상태, 특정 문제 상황이 발생하는 징조를 파악하는 것입니다. 모니터링을 잘 수행하면 더나은 서비스와 서비스 장애로 인한 손실을 예방할 수 있습니다.

- - -

###10.2 톰캣 기본 모니터링 툴

톰캣에는 기본적으로 제공하는 모니터링 툴이 있습니다. 자세하지는 않더라도 필요한 만큼의 정보를 제공합니다.

####10.2.1 Manager APP
앞서 어플리케이션의 배치를 통해 알아보았던 'Manager APP'에서는 다음의 정보를 확인 할 수 있습니다. 만약 호스트가 여러개라면 해당 'Manager APP' 어플리케이션을 별도로 배치하여 해당 호스트의 배치 정보를 확인 할 수 있습니다.

- 'Manager APP'에서의 수행 결과 메시지
- 배치된 어플리케이션의 상태
- 어플리케이션 배치 수행
- 메모리 릭 감지와 SSL 진단
- 실행되는 플랫폼 정보

그리고 상단의 'Server Status'링크를 통해 이동하면 다음의 정보를 확인 할 수 있습니다.

- 톰캣 프로세스의 JVM 메모리 모니터링
- 프로토콜 리스너의 처리중인 작업

배치된 어플리케이션의 Session의 숫자에 링크된 페이지에서는 현재 생성된 세션의 정보와 해당 세션을 강제 종료시킬 수 있는 'Sessoin Administration'을 제공합니다.

####10.2.2 host manager
'host manager'에서는 다음의 정보를 확인 할 수 있습니다.

- 호스트 목록의 확인과 정보 확인
- 호스트의 컨트롤
- 호스트 생성
- 실행되는 플랫폼 정보

####10.2.3 admin (톰캣 5.5)
톰캣 5.5 버전에서는 'admin' 어플리케이션이 제공됩니다. 다운로드의 아카이브 사이트에서 확인 가능하며 톰캣을 다운받기위한 버전하위에 'apache-tomcat-x.x.xx-admin' 이름을 갖는 파일이 있습니다. 여타 WAS에서 제공되는 만큼의 웹 콘솔 UI를 제공하는 관리 툴로서 톰캣 내에 설정과 각 항목의 정보를 파악할 수 있습니다. 다만 톰캣 5.5 이후로는 제공되지 않습니다.

![tomcatAdmin](https://www.googledrive.com/host/0B2BH_HdKKfdKWlgxZW45OWh2blE)

- - -

###10.3 pis-Probe

http://code.google.com/p/psi-probe

'psi-probe'는 예전에 'lambda probe'였으나 현재 구글에서 관리하기 시작한 후로 명칭이 변경되었습니다. 

'psi-probe'의 공식 웹 사이트의 다운로드 항목에서 파일을 받아 압축을 풀면 'probe.war' 웹 어플리케이션이 있습니다. 해당 어플리케이션을 톰캣에 배치하면 'psi-probe'를 실행할 수 있으며 'tomcat-user.xml'에 'manager'권한을 갖는 사용자로 접근하게 됩니다.

'[ip:port/probe](https://code.google.com/p/psi-probe/wiki/Features)'와 같이 톰캣에 요청하면 'psi-probe'가 제공하는 톰캣의 모니터링과 관리를 수행하는 어플리케이션을 확인 할 수 있습니다.

앞서 텍스트로만 표현되던 정보들도 보다 보기좋게 제공하고 각 자원이나 설정을 파악하는데 있어서 기본 톰캣 모니터링 툴보다 나은 기능을 제공합니다. 다만 일부 모니터링 항목은 5.5까지를 지원하고 톰캣 8.0에 대한 지원이 불가능하며 2013년 3월 이후로 업데이트가 없다는 점이 단점입니다.

- - -

###10.4 jkstatus

jkstatus는 'mod_jk'를 사용하여 연동한 경우 아파치에서 확인할 수 있는 톰켓 연동에 대한 모니터링 툴 입니다.

사용을 위해서 'worker.properties'에 'status' 워커를 추가합니다.

```apache
worker.list=tomcat1,tomcat2,loadbalancer,status

...

worker.status.type=status
```

그리고 'uri.properties'에 요청을 수행할 경로를 워커에 맵핑합니다.

```apache
...
/jkstatus=status
```

설정 후 아파치를 재기동하면 아파치 요청 url의 컨텍스트에 설정한 요청 경로를 입력하여 'jkstatus' 툴을 확인 할 수 있습니다. 앞서 80으로 요청하는 아파치의 경우 다음과 같이 요청 할 수 있습니다.

'[ip:port/jkstatus](http://tomcat.apache.org/connectors-doc/reference/status.html)'

![jkstatus](https://www.googledrive.com/host/0B2BH_HdKKfdKMnNBQnEyR3V5WVE)

jkstatus로 확인할 수 있는 정보는 다음과 같습니다.

- 아파치 버전, mod_jk 버전, uptime, jkstatus 뷰 타입
- 각 워커의 설정 값
- 워커에서 수행중인 요청
- 워커에 맵핑된 정보
- 항목 설명

- - -
    ###10.5 visualVM

visualVM은 톰캣만이 아닌 JVM 전반에 대해 모니터링을 제공하는 툴로서 제공됩니다. JDK 1.6.0_18 버전 이상부터는 기본으로 포함되어 있고 별도의 다운로드를 위해서는 관련 공식 페이지인 'http://visualvm.java.net'을 통해 받을 수 있습니다.

JDK에는 "$JAVA_HOMe/bin/jvisualvm"에 실행파일이 위치합니다.

visualVM의 장점중 하나는 플러그인 입니다. 현재까지도 상당수의 플러그인이 제공되고 있으며 플러그인 API가 공개되어 있어 원하는 모니터링 플러그인을 생성할 수도 있습니다.

자바 프로세스는 자체적으로 로컬환경에서는 visualVM에 자동으로 인지되게 됩니다. 따라서 수행중인 JVM 프로세스는 visualVM의 'Local'항목에 감지되어 목록에 나타납니다. 그리고 원격지의 JVM 프로세스 또한 JMX^Java^ ^Monitoring^ ^Extension^을 통해 로컬의 visualVM에서 모니터링 할 수 있습니다. 서비스로 등록된 로컬의 톰캣은 프로세스가 보이지 않기 때문에 리모트로 구성하는 방법을 따릅니다. 톰캣의 리모트 구성 방법은 두가지가 있습니다.

1. Java 기본 JMX 설정
   Java에서는 옵션을 통해 JMX를 활성화하고 설정 할 수 있습니다. 스크립트에 다음의 JMX의 옵션을 설정합니다.

```sh
#setenv.sh
CATALINA_OPTS="-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=18080
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false"
```

이 후 visualVM의 'Remote'에 플랫폼 IP를 등록하고 우클릭을 하면 'Add JMX connection...'을 통해 원격지의 톰캣을 등록할 수 있습니다.
![visualVMRemote1](https://www.googledrive.com/host/0B2BH_HdKKfdKcVJ3OV9scnRVY00)

2. jmx remote 모듈
   톰캣에서는 jmx를 위한 모듈을 제공합니다. 톰캣의 다운로드에 보면 'Extra'항목에 'Remote JMX jar'가 있습니다. 

 - 6.0 이상 버전의 경우 해당 jar 파일을 받아 "$CATALINA_HOME/lib/catalina-jmx-remote.jar"에 위치시킵니다.
 - 5.5 버전은 "$CATALINA_HOME/common/lib/catalina-jmx-remote.jar"에 위치시킵니다.

 Java에서는 옵션을 통해 JMX를 활성화하고 설정 할 수 있습니다. 스크립트에 다음의 JMX의 옵션을 설정합니다.

```sh
#setenv.sh
CATALINA_OPTS="-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false"
```

그리고 'server.xml'에 'Listener' 디스크립터로 "JmxRemoteLifecycleListener"를 추가합니다.

```xml
<Server port="8005" shutdown=“SHUTDOWN">

       <Listener className="org.apache.catalina.mbeans.JmxRemoteLifecycleListener"
                 rmiRegistryPortPlatform="10001" rmiServerPortPlatform="10002" />
```

설정된 톰캣은 visualVM의 Remote 등록시 다음의 정보로 접근 정보를 생성합니다.
`service:jmx:rmi://192.168.56.101:10002/jndi/rmi://192.168.56.101:10001/jmxrmi`
![visualVMRemote2](https://www.googledrive.com/host/0B2BH_HdKKfdKRldBVXVPeG8yWkU)

로컬이나 리모트에 설정된 톰캣 프로세스는 좌측의 네비게이션에 나타나며 해당 항목을 더블클릭하여 우측 화면에서 모니터링 하게 됩니다.

![visualVMMain](https://www.googledrive.com/host/0B2BH_HdKKfdKNGxxZlhsd1VBYTA)

visualVM에서는 기본적으로 다음의 기능을 제공합니다.

- Overview: 해당 JVM의 설정 정보와 환경
- Monitor: CPU, 메모리, 쓰레드 수, 클래스 수의 모니터링과 힘 덤프 수행
- Threads: 쓰레드의 동작 상태와 쓰레드 덤프 수행

이외에도 플러그인에서 제공하는 기능을 활용한 다양한 모니터링이 가능합니다.

- - -

###10.6 JMC

http://www.oracle.com/technetwork/java/javase/2col/jmc-relnotes-2004763.html

JMC^Java^ ^Mision^ ^control^은 bea사에서 만든 별도의 JDK인 JRockit에서 제공하던 모니터링 툴입니다. 현재는 bea가 오라클사에서 인수하면서 관련 소프트웨어도 오라클이 관리하고 있으며 관련하여 Sun사도 인수하면서 기존 Sun Hotspot JDK와 JRockit의 장점을 합친 결과로 여러 기능이 추가되고 있습니다. 특히 JDK 7에서 많은 변화가 있었으며 여기에 JMC가 포함되었습니다.

JDK 7 이상의 버전에서 "$JAVA_HOME/bin/jmc"로 실행시키며, 수행된 툴은 다음과 같은 모습을 갖고 있습니다.
![jmc](https://www.googledrive.com/host/0B2BH_HdKKfdKZ2g1dGVUZko3c1k)

visualVM과 거의 비슷한 정도의 모니터링 기능을 제공하는 JMC의 대표적인 특징은 GC 정책에 따른 모니터링 탭의 변화 입니다. GC 정책은 기본 Parellel GC외에도 필요에 따라 CMS^Concurrent^ ^Mark^ ^Sweep^이나 G1 정책이 사용될 수 있는데 이런 GC 정책에 따른 뷰가 변경됨이 큰 특징입니다.

![jmcGC](https://www.googledrive.com/host/0B2BH_HdKKfdKY0twMHVCZVFFblU)

- - -

###10.7 APM

APM은 Application Performence Manager의 약자로 모니터링의 역할과 더불어 어플리케이션의 성능을 향샹시킬 목적으로 사용되는 별도의 어플리케이션입니다. WAS의 상용 APM 으로는 Jennifer, Pharos, Performizer 등이 있고 Opensource로 RHQ Project가 대표적입니다.

RHQ의 경우 톰캣의 플러그인도 제공하고 RDBMS와의 연계를 통해 지속적인 모니터링 데이터의 수집과 관리가 가능하다는 장점이 있으나 어느정도 상용 APM에 버금가는 수준을 맞추기 위해서는 별도의 플러그인 개발이 요구된다는 점이 있습니다.

* * *

##11. 팁

- 디렉토리
- setenv
- 실행 유저
- Connector

@[팁](http://youtu.be/zY0pDLOZ_7U)

- - -

###11.1 디렉토리
하나의 장비에는 둘 이상의 톰캣을 운영하는 경우가 발생합니다. 이경우 설정 파일을 별도로 생성하고 스크립트를 통해 해당 설정을 읽게 하는 식의 방법을 사용할 수도 있지만 기본 제공되는 스크립트가 수정되는 양이 많을수록 관리의 난이도가 증가합니다. 따라서 톰캣의 프로세스를 여러개 기동하기 위한 방법으로 권장하는 것을 '$CATALINA_HOME'을 단순히 여러개 만드는 것입니다. 톰캣은 그 자체 용량이 그리 크지 않기 때문에 여러개 복사한다하여도 큰 무리 없이 사용가능한 가벼운 엔진 입니다. 따라서 설정 파일을 추가로 구성하고 스크립트를 수정하는 방법 보다는 기본 톰캣 엔진 전체를 복사하는 것을 권장합니다.

###11.2 setenv
앞서 옵션을 적용함에 있어 강조한 setenv를 다시한번 강조 하고자 합니다. 톰캣에 대한 서비스를 지원하다보면 주로 'catalina.sh(bat)'를 수정하는 경우가 대부분이고 현재가지는 운영중인 서비스에 'setenv'사용한 사례를 본적은 없는 것 같습니다. 하지만 'catalina.sh(bat)' 스크립트에서도 명시하듯 해당 스크립트를 수정하는 것은 설정한다는 이유 외에는 단점이 더 많기 때문에 반드시 'setenv'를 통해 추가적인 스크립트 추가 설정을 권장합니다.

###11.3 실행 유저
유닉스/리눅스/맥 플랫폼에서 톰캣이 별도의 계정으로 구성되어 있지만 간혹 root 계정으로 실수로 기동하는 경우가 발생합니다. 톰캣에서는 'server.xml'에 다음의 설정으로 root 로의 기동을 방지 할 수 있습니다.

```xml
<Server port="8005" shutdown="SHUTDOWN">
  <Listener className="org.apache.catalina.security.SecurityListener" checkedOsUsers="root" />
  ...
```

이러한 'Listener' 디스크립터의 설정으로 root 계정의 실행을 방지하며, 만약 root로 기동하는 경우 다음과 같은 메시지를 발생시킵니다.

```log
java.lang.Error: Start attempted while running as user [root]. Running Tomcat as this user has been blocked by the Lifecycle listener org.apache.catalina.security.SecurityListener (usually configured in CATALINA_BASE/conf/server.xml)
```

###11.4 Connector
'Connector' 디스크립터로 정의되는 프로토콜에 대한 정의는 톰캣이 요청을 받아들이는 통로를 설정하는 것이기 때문에 주요 설정 중 하나 입니다. 앞서 살펴본 쓰레드 설정외에도 도움이 될만한 옵션에 대한 내용은 다음과 같습니다.

|옵션|기능 설명|
|-|
|acceptCount="10"|request Queue의 길이를 정의
||: idle thread가 없으면 queue에서 idle thread가 생길때 까지 요청을 대기하는 queue의 길이|
||: 요청을 처리할 수 없는 상황이면 빨리 에러 코드를 클라이언트에게 보내서 에러처리 표시|
|enableLookups="false"|Servlet/JSP 코드 중에서 들어오는 http request에 대한 ip를 조회 하는 명령등이 있을 경우 DNS 이름을 IP주소로 바꾸기 위해서 DNS 서버에 look up 요청을 보냄|
||: 서버간의 round trip 발생을 막을 수 있음|
|compression="off"|HTTP message body를 gzip 형태로 압축해서 리턴하지 않음|
|maxConnection="8192"|하나의 톰캣인스턴스가 유지할 수 있는 Connection의 수를 정의|
||: 현재 연결되어 있는 실제 Connection의 수가 아니라 현재 사용중인 socket fd (file descriptor)의 수|
|maxKeepAliveRequest="1"|HTTP 1.1 Keep Alive Connection을 사용할 때, 최대 유지할 Connection 수를 결정하는 옵션|
||: Keep Alive를 사용할 환경이 아닌 경우에 설정|
|tcpNoDelay="true"|TCP 프로토콜은 기본적으로 패킷을 보낼때 바로 보내지 않음|
||: 버퍼사이즈에 데이터가 모두 담길때까지 패킷 전송을 보류함으로 대기 시간이 발생하는 것을 방지|
||: 트래픽이 증가하지만 현 망 속도를 고려하였을 때 문제가 크지 않음|

* * *

긴긴 내용 읽고, 보시느라 수고하셨습니다.

Writen by 이규석